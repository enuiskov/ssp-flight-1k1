stuff.list
({
	"../ClassLibrary/Base.chs" : "\"use strict\";\r\n\r\nstuff\r\n ({\r\n	'PrivateCollection' : \r\n	 {\r\n		Owner : obj,\r\n		Items : arr,\r\n\r\n		constructor : function(iOwner, iItems)\r\n		 {\r\n			this << iOwner;\r\n			this << iItems || [];\r\n		 },\r\n\r\n		SetOwner : function(iOwner)\r\n		 {\r\n			this << iOwner;\r\n\r\n			this.Items.ForEach(function(cI){cI.Parent = iOwner});\r\n		 },\r\n		SyncItem : function(){/* empty */},\r\n\r\n		Add : function(iI)\r\n		 {\r\n			iI.Owner = this.Owner;\r\n\r\n			this.Items.Add(iI);\r\n		 },\r\n		AddRange : function(iII)\r\n		 {\r\n			for(var cI,Ii = 0; cI = iII[Ii], Ii < iII.Length; Ii++)\r\n			{\r\n				this.Add(cI);\r\n			}\r\n		 },\r\n	 }\r\n });\r\n",
	"../ClassLibrary/System/Data.chs" : "\"use strict\";\r\n\r\nstuff\r\n ({\r\n	uses : \r\n	[\r\n		'Math',\r\n	],\r\n\r\n	'System.Data' :\r\n	 {\r\n		'TimeSeries' : \r\n		 {\r\n			'Set' :\r\n			 {\r\n				Entries : arr('Entry'),\r\n\r\n				constructor : function(iEntries)\r\n				 {\r\n					this << iEntries || [];\r\n				 },\r\n				\r\n				Add : function(iEntry)\r\n				 {\r\n					this.Entries.Add(iEntry);\r\n				 },\r\n				CreateEntry : function(iTime, iValue, oEntry)\r\n				 {\r\n					var oEntry = new TimeSeries.Entry(iTime, iValue);\r\n					\r\n					this.Add(oEntry);\r\n\r\n					return oEntry;\r\n				 },\r\n				\r\n			 },\r\n			'Entry' : \r\n			 {\r\n				Time  : obj('Date'),\r\n				Value : any,\r\n				\r\n				constructor : function(iTime, iValue)\r\n				{\r\n					this << iTime  || new Date(0);\r\n					this << iValue || undefined;\r\n				},\r\n			 },\r\n			'Range' :\r\n			 {\r\n				MinI : num,\r\n				MaxI : num,\r\n				MinT : obj('Date'),\r\n				MaxT : obj('Date'),\r\n\r\n				LowI : num,\r\n				UppI : num,\r\n				LowT : obj('Date'),\r\n				UppT : obj('Date'),\r\n\r\n				constructor : function(iSeries, iFrT, iToT, iFrI, iToI)\r\n				{\r\n					if(!iSeries)             throw \"No series specified\";\r\n					if( iSeries.Length == 0) throw \"Empty series specified\";\r\n\r\n					this.MinI = 0;\r\n					this.MaxI = iSeries.Length - 1;\r\n					this.MinT = iSeries[this.MinI].Time;\r\n					this.MaxT = iSeries[this.MaxI].Time;\r\n\r\n					this.LowI = (iFrI != undefined) ? iFrI : this.MinI;\r\n					this.UppI = (iToI != undefined) ? iToI : this.MaxI;\r\n					\r\n					this.LowT = (iFrT != undefined) ? iFrT : this.MinT;\r\n					this.UppT = (iToT != undefined) ? iToT : this.MaxT;\r\n				},\r\n			 }\r\n		 }\r\n	 }\r\n });\r\n",
	"../ClassLibrary/System/Drawing.chs" : "\"use strict\";\r\n\r\nstuff\r\n ({\r\n	'System.Drawing' :\r\n	 {\r\n		'DockStyle' :\r\n		 {\r\n			Fill   : \"Fill\"   ,\r\n			Top    : \"Top\"    ,\r\n			Bottom : \"Bottom\" ,\r\n			Left   : \"Left\"   ,\r\n			Right  : \"Right\"  ,\r\n			None   : \"None\"   ,\r\n		 },\r\n		\r\n		'GraphicsLayer'      : \r\n		 {\r\n			Canvas      : nil ('HTMLCanvasElement'),\r\n			Context     : nil ('CanvasRenderingContext2D'),\r\n			Bounds      : obj ('Rectangle', 0,0,1,1),\r\n			Dock        : str (\"Fill\"),\r\n			\r\n			ForeColor   : obj('Color',0,0,0),\r\n			BackColor   : obj('Color',255,255,255),\r\n\r\n			IsVisible   : boo(true),\r\n			Opacity     : num(1),\r\n			ZIndex      : num(1),\r\n\r\n			//IsForeValidated : boo,\r\n			//IsBackValidated : boo,\r\n\r\n			constructor : function annex(iAA)\r\n			 {\r\n				//this << iAA.Dock      || DockStyle.Fill;\r\n				//this << iAA.Bounds    || new Rectangle(0,0,1,1);//new Rectangle(0.25,0.25,0.5,0.5);\r\n				////this << iAA.Bounds    || error;\r\n				//this << iAA.ForeColor || Colors.Black;\r\n				//this << iAA.BackColor || Colors.White;\r\n				//this << iAA.IsVisible || true;\r\n				//this << iAA.Opacity   || 1;\r\n				//this << iAA.ZIndex    || 1;\r\n				\r\n				\r\n				//this(Dock, DockStyle.None);\r\n\r\n				//this.Dock      = iAA.Dock      || DockStyle.None;\r\n				//this.Bounds    = iAA.Bounds    || new Rectangle(0.25,0.25,0.5,0.5);\r\n				//this.ForeColor = iAA.ForeColor || Colors.Black;\r\n				//this.BackColor = iAA.BackColor || Colors.White;\r\n				//this.ZIndex    = iAA.ZIndex    || \r\n\r\n\r\n				this.Canvas = document.createElement(\"canvas\");\r\n				{\r\n					var _S = this.Canvas.style;\r\n					{\r\n						_S.position = \"fixed\";\r\n						_S.opacity  = \"0.5\";//this.Opacity + \"\";\r\n						_S.zIndex   = this.ZIndex;\r\n					}\r\n					//_S.visibility = \"hidden\";\r\n					//_S.border     = \"#ff0000 2px dashed\";\r\n					//this.Canvas.style.visibility = this.IsVisible ? \"visible\" : \"hidden\";\r\n					this.ToggleVisibility(this.IsVisible);\r\n					document.body.appendChild(this.Canvas);\r\n				}\r\n				this.Context         = this.Canvas.getContext(\"2d\");\r\n				this.IsForeValidated = false;\r\n				this.IsBackValidated = false;\r\n\r\n				\r\n\r\n				window.addEventListener(\"resize\", this.UpdateBounds.Bind(this));\r\n\r\n				this.UpdateBounds();\r\n				window.setInterval\r\n				(\r\n					function()\r\n					{\r\n						if(!this.IsVisible) return;\r\n						\r\n						//this.Opacity;\r\n\r\n						if(this.IsForeValidated && this.IsBackValidated) return;\r\n\r\n						this.Validate(!this.IsForeValidated, !this.IsBackValidated);\r\n					}\r\n					.Bind(this), 100\r\n				);\r\n			 },\r\n\r\n			UpdateBounds     : function()\r\n			 {\r\n				var _WinW = window.innerWidth, _WinH = window.innerHeight;\r\n				var _E = this.Canvas, _BB = this.Bounds, _S = _E.style;\r\n				var _X,_Y,_W,_H;\r\n				{\r\n					if(Math.Max(Math.Abs(_BB.X),Math.Abs(_BB.Y),Math.Abs(_BB.W),Math.Abs(_BB.H)) > 1)\r\n					{\r\n						_BB = new Rectangle(_BB.X / _WinW, _BB.Y / _WinH, _BB.W / _WinW, _BB.H / _WinH);\r\n					}\r\n					switch(this.Dock)\r\n					{\r\n						case DockStyle.None   : _X = _BB.X;      _Y = _BB.Y;      _W = _BB.W;  _H = _BB.H;     break;\r\n						case DockStyle.Fill   : _X = 0;          _Y = 0;          _W = 1;      _H = 1;         break;\r\n\r\n						case DockStyle.Top    : _X = 0;          _Y = 0;          _W = 1;      _H = _BB.H;     break;\r\n						case DockStyle.Bottom : _X = 0;          _Y = 1 - _BB.H;  _W = 1;      _H = _BB.H;     break;\r\n						case DockStyle.Left   : _X = 0;          _Y = 0;          _W = _BB.W;  _H = 1;         break;\r\n						case DockStyle.Right  : _X = 1 - _BB.W;  _Y = 0;          _W = _BB.W;  _H = 1;         break;\r\n\r\n						default               : throw \"WTF\";\r\n					}\r\n					_X = Math.Round(_X * _WinW); _Y = Math.Round(_Y * _WinH);\r\n					_W = Math.Round(_W * _WinW); _H = Math.Round(_H * _WinH);\r\n				}\r\n\r\n				_E.width  = _W;\r\n				_E.height = _H;\r\n\r\n				_S.left   = _X + \"px\";\r\n				_S.top    = _Y + \"px\";\r\n				_S.width  = _W + \"px\";\r\n				_S.height = _H + \"px\";\r\n\r\n				this.Context.UpdateSize();\r\n				this.Invalidate(true, true);\r\n			 },\r\n			Invalidate       : function(iDoFore, iDoBack)\r\n			 {\r\n				if(iDoFore == undefined && iDoBack == undefined) iDoFore = true;\r\n				if(iDoFore) this.IsForeValidated = false;\r\n				if(iDoBack) this.IsBackValidated = false;\r\n			 },\r\n			Validate         : function(iDoFore, iDoBack)\r\n			 {\r\n				//if(!this.IsVisible || this.IsValidated) return;\r\n				if(iDoBack && this.UpdateBackground != undefined)\r\n				{\r\n					this.Context.ResetTransform();\r\n					this.Context.GlobalAlpha = 1;\r\n					\r\n					this.Context.Save();\r\n					{\r\n						this.Context.StrokeStyle = this.BackColor;\r\n						this.Context.FillStyle   = this.BackColor;\r\n						\r\n						this.UpdateBackground();\r\n						this.IsBackValidated = true;\r\n					}\r\n					this.Context.Restore();\r\n\r\n					this.Canvas.style.background = \" url('\" + this.Canvas.toDataURL() + \"')\";\r\n\r\n					this.Context.ClearRect(0,0,this.Context.W, this.Context.H);\r\n				}\r\n				if(iDoFore)\r\n				{\r\n					this.Context.ResetTransform();\r\n					this.Context.GlobalAlpha = 1;\r\n					\r\n					this.Context.Save();\r\n					{\r\n						this.Context.StrokeStyle = this.ForeColor;\r\n						this.Context.FillStyle   = this.ForeColor;\r\n						\r\n						this.UpdateForeground();\r\n						this.IsForeValidated = true;\r\n					}\r\n					this.Context.Restore();\r\n				}\r\n			 },\r\n			//UpdateBackground : function()\r\n			//{\r\n				//GraphicsLayer.Drawing.DrawBackground(this, this.Context);\r\n			//},\r\n			UpdateBackground : undefined,\r\n			UpdateForeground : function()\r\n			 {\r\n				//var _Ctx = this.Context;\r\n\r\n			 },\r\n			ToggleVisibility : function(iMode$boo)\r\n			 {\r\n				if(iMode == undefined) iMode = !this.IsVisible;\r\n\r\n				this.Canvas.style.opacity = iMode ? 1 : 0;\r\n				this.IsVisible = iMode;\r\n			 },\r\n			\r\n			\r\n			static : \r\n			{\r\n				Drawing : \r\n				{\r\n					DrawBackground : function(iLayer, iCtx, iBackC, iForeC)\r\n					{\r\n						var iCtx = iLayer.Context;\r\n\r\n						iCtx.FillStyle   = iBackC || iLayer.BackColor;\r\n						iCtx.StrokeStyle = iForeC || iLayer.ForeColor;\r\n\r\n						iCtx.BeginPath();\r\n						 iCtx.AddRect(3, 3, iCtx.W - 6, iCtx.H - 6, 5);\r\n						iCtx.Fill();\r\n						 //iCtx.MoveTo(5,         5); iCtx.LineTo(iCtx.W - 5,iCtx.H - 5);\r\n						 //iCtx.MoveTo(5,iCtx.H - 5); iCtx.LineTo(iCtx.W - 5,         5);\r\n						iCtx.Stroke();\r\n					},\r\n				}\r\n			}\r\n		 },\r\n		'LayerSet'           :\r\n		 {\r\n			Contexts    : arr('CanvasRenderingContext2D'),\r\n			Bounds      : obj('Rectangle'),\r\n\r\n			constructor : function(iGrxA)\r\n			 {\r\n				if(iGrxA != undefined && !(iGrxA instanceof Array)) throw \"WTF\";\r\n\r\n				this.Bounds  = new Bounds(0,0,1,1);\r\n				this.Contexts = [];\r\n\r\n				if(iGrxA) this.Update(iGrxA);\r\n\r\n				this.SetBounds();\r\n			 },\r\n			Update      : function(iGrxA)\r\n			 {\r\n				//this.Length = iGrxA.Length;\r\n				this.Contexts = [];\r\n\r\n				//for(var cE,Ei = 0; cE = arguments[Ei], Ei < arguments.length; Ei++)\r\n				\r\n				for(var cC,Ci = 0; cC = iGrxA[Ci], Ci < iGrxA.Length; Ci++)\r\n				{\r\n					if         (cC == undefined) continue;\r\n					else if    (cC instanceof CanvasRenderingContext2D) this.Contexts[Ci] = cC;\r\n					else if    (cC instanceof HTMLCanvasElement)        this.Contexts[Ci] = cC = cC.getContext(\"2d\");\r\n					else throw \"Object type '\" + cC.constructor.name + \"' not supported\";\r\n\r\n					cC.Layer = Ci;\r\n				}\r\n				//for(let cC,Ci = 0; cC = iGrxA[Ci], Ci < iGrxA.Length; Ci++)\r\n				//{\r\n					//if         (cC == --) continue;\r\n					//else if    (cC instanceof CanvasRenderingContext2D) own.Contexts[Ci] = cC;\r\n					//else if    (cC instanceof HTMLCanvasElement)        own.Contexts[Ci] = cC = cC.getContext(\"2d\");\r\n					//else throw \"Object type '\" + cC.constructor.name + \"' not supported\";\r\n\r\n					//cC.Layer = Ci;\r\n				//}\r\n			 },\r\n			SetBounds   : function(iX,iY,iW,iH)\r\n			 {\r\n				var _BaseG = this.Contexts[0] || this.Contexts[1] || this.Contexts[2] || this.Contexts[3] || this.Contexts[4];\r\n\r\n				if(arguments.length != 4 && _BaseG)\r\n				{\r\n					iX = _BaseG.canvas.clientLeft;\r\n					iY = _BaseG.canvas.clientTop;\r\n					iW = _BaseG.canvas.clientWidth;\r\n					iH = _BaseG.canvas.clientHeight;\r\n				}\r\n				this.Bounds.SyncR2A(Bounds.FromAbsolute(iX,iY,iW,iH));\r\n				\r\n				for(var cG,Gi = 0; cG = this.Contexts[Gi], Gi < this.Contexts.Length; Gi++)\r\n				{\r\n					if(!cG) continue;\r\n					if(cG.canvas.width == iW && cG.canvas.height == iH) continue;\r\n					\r\n					cG.canvas.width  = iW;\r\n					cG.canvas.height = iH;\r\n\r\n					cG.canvas.style.left   = iX + \"px\";\r\n					cG.canvas.style.top    = iY + \"px\";\r\n					\r\n					cG.canvas.style.width  = iW + \"px\";\r\n					cG.canvas.style.height = iH + \"px\";\r\n				}\r\n			 },\r\n		 },\r\n\r\n\r\n		'Colors'             :\r\n		 {\r\n			Random       : {get : function(){return new Color(Math.Random() * 255, Math.Random() * 255, Math.Random() * 255);}},\r\n			Transparent  : ('Color',   0,   0,   0,   0),\r\n			\r\n			Black        : ('Color',   0,   0,   0),\r\n			White        : ('Color', 255, 255, 255),\r\n			Grey         : ('Color', 127, 127, 127),\r\n\r\n			Red          : ('Color', 255,   0,   0),\r\n			Green        : ('Color',   0, 200,   0),\r\n			Blue         : ('Color',   0,   0, 255),\r\n\r\n			Yellow       : ('Color', 255, 255,   0),\r\n\r\n		 },\r\n		'Color'              :\r\n		 {\r\n			R : num(0,0,255),\r\n			G : num(0,0,255),\r\n			B : num(0,0,255),\r\n			A : num(0,0,1),\r\n\r\n			AsString : str,\r\n			\r\n			constructor   : function(iR$num,iG$num,iB$num,iA$num)\r\n			 {\r\n				this << iR || 0;\r\n				this << iG || 0;\r\n				this << iB || 0;\r\n				this << iA || 1;\r\n\r\n				this.UpdateString();\r\n			 },\r\n			GetBrightness : function(oV$num)\r\n			 {\r\n				var _R = this.R / 255, _G = this.G / 255, _B = this.B / 255;\r\n				return (Math.Min(_R,_G,_B) + Math.Max(_R,_G,_B)) / 2;\r\n			 },\r\n			SetValue      : function(iV$num,oC$Color)\r\n			 {\r\n				return new Color\r\n				(\r\n					Math.Floor(this.R * iV),\r\n					Math.Floor(this.G * iV),\r\n					Math.Floor(this.B * iV)\r\n				);\r\n			 },\r\n			//SetBrightness : function(oV$num)\r\n			//{\r\n				//var _R = this.R / 255, _G = this.G / 255, _B = this.B / 255;\r\n				//return (Math.Min(_R,_G,_B) + Math.Max(_R,_G,_B)) / 2;\r\n			//},\r\n\r\n			UpdateString  : function()          {this.AsString = \"rgba(\" + Math.Floor(this.R) + \",\" + Math.Floor(this.G) + \",\" + Math.Floor(this.B) + \",\" + this.A + \")\"},\r\n			Clone         : function(oC$Color)  {return new Color(this.R,this.G,this.B,this.A)},\r\n			valueOf       : function(oV)        {return this.AsString},\r\n			toString      : function(oS)        {return this.AsString},\r\n			\r\n			static :\r\n			 {\r\n				ModifyAlpha     : function(iC$Color,iNewA$num)\r\n				 {\r\n					return new Color(iC.R, iC.G, iC.B, iNewA);\r\n				 },\r\n				FromString      : function(iS$str, oC$Color)\r\n				 {\r\n					if     (iS.StartsWith(\"#\"))    return Color.FromHexString  (iS);\r\n					else if(iS.StartsWith(\"rgba\")) return Color.FromRGBAString (iS);\r\n					else if(iS.StartsWith(\"rgb\"))  return Color.FromRGBString  (iS);\r\n\r\n					else throw \"Color format not supported\";\r\n				 },\r\n				FromRGBString   : function(iS$str, oC$Color)\r\n				 {\r\n					iS = iS.Match(/rgba\\((\\d+),(\\d+),(\\d+)\\)/);\r\n\r\n					return new Color(parseInt(iS[1]), parseInt(iS[2]), parseInt(iS[3]));\r\n				 },\r\n				FromRGBAString  : function(iS$str, oC$Color)\r\n				 {\r\n					iS = iS.Match(/rgba\\((\\d+),(\\d+),(\\d+),(\\d+)\\)/);\r\n\r\n					return new Color(parseInt(iS[1]), parseInt(iS[2]), parseInt(iS[3]), parseInt(iS[4]));\r\n				 },\r\n				FromHexString   : function(iS$str, oC$Color)\r\n				 {\r\n					return new Color\r\n					(\r\n						parseInt(iS.Substring(1,3),16),\r\n						parseInt(iS.Substring(3,5),16),\r\n						parseInt(iS.Substring(5,7),16)\r\n					);\r\n				 },\r\n			 }\r\n		 },\r\n		//'HSLColor : Color'   : //~~meta; info=\"\";\r\n		 //{\r\n			//H : num(0,1),\r\n			//S : num(0,1),\r\n			//L : num(0,1),\r\n\r\n			//instance : \r\n			 //{\r\n				//constructor : function(iC$Color)\r\n				 //{\r\n					//if(arguments.length == 1 && iC instanceof Color)\r\n					//{\r\n						//this.overriden(iC.R,iC.G,iC.B);\r\n					//}\r\n					//else this.overriden(arguments);\r\n\r\n					//this.UpdateHSL();\r\n				 //},\r\n				//UpdateHSL : function()\r\n				//{\r\n					//var r = this.R, g = this.G, b = this.B;\r\n\r\n					//r /= 255, g /= 255, b /= 255;\r\n					//var max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n					//var h, s, l = (max + min) / 2;\r\n\r\n					//if(max == min) h = s = 0; // achromatic\r\n					//else\r\n					//{\r\n						//var d = max - min;\r\n						//s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n						//switch(max){\r\n							//case r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n							//case g: h = (b - r) / d + 2; break;\r\n							//case b: h = (r - g) / d + 4; break;\r\n						//}\r\n						//h /= 6;\r\n					//}\r\n\r\n					//this.H = h;\r\n					//this.S = s;\r\n					//this.L = l;\r\n				//},\r\n\r\n				//UpdateRGB : function()\r\n				 //{\r\n					//var h = this.H, s = this.S, l = this.L;\r\n					//var r, g, b;\r\n\r\n					//if(s == 0)\r\n					//{\r\n						//r = g = b = l; // achromatic\r\n					//}\r\n					//else\r\n					//{\r\n						//var hue2rgb = function(p, q, t)\r\n						//{\r\n							//if(t < 0) t += 1;\r\n							//if(t > 1) t -= 1;\r\n							//if(t < 1/6) return p + (q - p) * 6 * t;\r\n							//if(t < 1/2) return q;\r\n							//if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n							//return p;\r\n						//}\r\n\r\n						//var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n						//var p = 2 * l - q;\r\n\r\n						//r = hue2rgb(p, q, h + 1/3);\r\n						//g = hue2rgb(p, q, h);\r\n						//b = hue2rgb(p, q, h - 1/3);\r\n					//}\r\n\r\n					//this.R = Math.Floor(r * 255);\r\n					//this.G = Math.Floor(g * 255);\r\n					//this.B = Math.Floor(b * 255);\r\n				 //},\r\n				//Clone        : function(oC$HSLColor)\r\n				 //{\r\n					//return new HSLColor(this.R,this.G,this.B,this.A);\r\n				 //},\r\n			 //},\r\n			//static   :\r\n			 //{\r\n				//FromRGB : function (iC)\r\n				 //{\r\n					//var r = iC.R, g = iC.G, b = iC.B;\r\n\r\n					 //r /= 255, g /= 255, b /= 255;\r\n					 //var max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n					 //var h, s, l = (max + min) / 2;\r\n\r\n					 //if(max == min){\r\n						  //h = s = 0; // achromatic\r\n					 //}else{\r\n						  //var d = max - min;\r\n						  //s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n						  //switch(max){\r\n								//case r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n								//case g: h = (b - r) / d + 2; break;\r\n								//case b: h = (r - g) / d + 4; break;\r\n						  //}\r\n						  //h /= 6;\r\n					 //}\r\n\r\n					 //return new HSLColor(h, s, l);\r\n				 //},\r\n			 //}\r\n		 //},\r\n		'Point'              :\r\n		 {\r\n			X : num,\r\n			Y : num,\r\n			\r\n			constructor : function Point(iX$num,iY$num)\r\n			 {\r\n				this << iX || 0;\r\n				this << iY || 0;\r\n			 },\r\n			toString    : function()\r\n			 {\r\n				return this.X + \" x \" + this.Y;\r\n			 },\r\n\r\n			static:\r\n			 {\r\n				\r\n			 }\r\n		 },\r\n		'Vector'             :\r\n		 {\r\n			X : num,\r\n			Y : num,\r\n\r\n			constructor : function(iX,iY)\r\n			 {\r\n				this << iX || 0;\r\n				this << iY || 0;\r\n			 },\r\n		 },\r\n		'Size'               :\r\n		 {\r\n			Width  : num,\r\n			Height : num,\r\n\r\n			constructor : function(iWidth$num,iHeight$num)\r\n			 {\r\n				this << iWidth  || 0;\r\n				this << iHeight || 0;\r\n			 },\r\n\r\n			toString : function()\r\n			 {\r\n				return this.Width + \"x\" + this.Height;\r\n			 }\r\n		 },\r\n		'Rectangle'          :\r\n		 {\r\n			X : num,\r\n			Y : num,\r\n			W : num,\r\n			H : num,\r\n	\r\n			constructor : function(iX,iY,iW,iH)\r\n			 {\r\n				this << iX;\r\n				this << iY;\r\n				this << iW;\r\n				this << iH;\r\n			 },\r\n\r\n			Project   : function(iObj)\r\n			 {\r\n				if(iObj instanceof Rectangle)\r\n				{\r\n					var oR = new Rectangle\r\n					(\r\n						this.X + (iObj.X * this.W),\r\n						this.Y + (iObj.Y * this.H),\r\n\r\n						iObj.W * this.W,\r\n						iObj.H * this.H\r\n					);\r\n					return oR;\r\n				}\r\n				else throw \"NI\";\r\n			 },\r\n			UnProject : function(iObj$any, oObj$any)\r\n			 {\r\n				throw \"NI\";\r\n			 },\r\n		 },\r\n		'Bounds'             :\r\n		 {\r\n			AX : num(NaN),\r\n			AY : num(NaN),\r\n			AW : num(NaN),\r\n			AH : num(NaN),\r\n\r\n			RX : num(NaN),\r\n			RY : num(NaN),\r\n			RW : num(NaN),\r\n			RH : num(NaN),\r\n\r\n			//constructor : function auto(iRX,iRY,iRW,iRH, iAX,iAY,iAW,iAH){auto},\r\n\r\n\r\n			constructor : function(iRX,iRY,iRW,iRH, iAX,iAY,iAW,iAH)\r\n			 {\r\n				this << iRX || NaN;\r\n				this << iRY || NaN;\r\n				this << iRW || NaN;\r\n				this << iRH || NaN;\r\n\r\n				this << iAX || NaN;\r\n				this << iAY || NaN;\r\n				this << iAW || NaN;\r\n				this << iAH || NaN;\r\n			 },\r\n\r\n			SyncR2A : function(iPareB)\r\n			 {\r\n				this.AX = iPareB.AX + (iPareB.AW * this.RX);\r\n				this.AY = iPareB.AY + (iPareB.AH * this.RY);\r\n				this.AW = iPareB.AW * this.RW;\r\n				this.AH = iPareB.AH * this.RH;\r\n			 },\r\n			\r\n			SyncA2R : function(iPareB)\r\n			 {\r\n				throw \"NI\";\r\n			 },\r\n			\r\n			static :\r\n			{\r\n				FromAbsolute : function(iAX,iAY,iAW,iAH,oBB){return oBB = new Bounds(NaN,NaN,NaN,NaN,iAX,iAY,iAW,iAH);},\r\n				FromRelative : function(iRX,iRY,iRW,iRH,oBB){return oBB = new Bounds(iRX,iRY,iRW,iRH,NaN,NaN,NaN,NaN);},\r\n			}\r\n		 },\r\n		'CircleBounds'       :\r\n		 {\r\n			X        : num,\r\n			Y        : num,\r\n			Align    : str(\"CC\", \"(C|L|R)(C|T|B)\"), //~~meta; info=\"Applies X and Y coordinates to specified bounds. 'C' is Center\"\r\n			Diameter : num(1),                      //~~meta; info=\"Diameter (maximum value of master property)\"\r\n			Aspect   : num(1),                      //~~meta; info=\"Aspect ratio for slave property (S/M)\"\r\n			Master   : str(\"W\", \"W|H\"),             //~~meta; info=\"Specifies master property for the use as 'diameter'\"\r\n\r\n			AX       : num,\r\n			AY       : num,\r\n			AW       : num,\r\n			AH       : num,\r\n\r\n			//constructor : ctor('iX,iY,iAlign,iDiameter,iAspect,iMaster'),\r\n\r\n			constructor : function(iX$num, iY$num, iAlign$str, iDiameter$num, iAspect$num, iMaster$str) //~~meta; info=\"???? Aspect ratio is signed (+V=Hs/Wm, -V=Ws/Hm)\"\r\n			{\r\n				this << iX;\r\n				this << iY;\r\n				this << iAlign    || \"CC\";\r\n				this << iDiameter || 1;\r\n				this << iAspect   || 1;\r\n				this << iMaster   || \"W\";\r\n\r\n				\r\n\r\n				this.AX = NaN;\r\n				this.AY = NaN;\r\n				this.AW = NaN;\r\n				this.AH = NaN;\r\n			},\r\n			SyncR2A : function(iPareB$Bounds)\r\n			 {\r\n				Size:\r\n				{\r\n					var _WIsM = this.Master == \"W\", _HIsM = !_WIsM;\r\n\r\n					var _MasV = this.Diameter * (_WIsM ? iPareB.AW : iPareB.AH);\r\n					var _SlaV = _MasV * this.Aspect;\r\n\r\n					this.AW = _WIsM ? _MasV : _SlaV;\r\n					this.AH = _HIsM ? _MasV : _SlaV;\r\n				}\r\n				Position:\r\n				{\r\n					var _HrzB = this.Align[0];\r\n					var _VrtB = this.Align[1];\r\n\r\n					var _OffsX = 0, _OffsY = 0;\r\n					var _W = this.AW, _H = this.AH;\r\n\r\n					switch(_HrzB)\r\n					{\r\n						case \"C\" : _OffsX = -_W / 2; break;\r\n						case \"L\" : _OffsX = 0;       break;\r\n						case \"R\" : _OffsX = -_W;     break;\r\n\r\n						default: \"WTF\";\r\n					}\r\n					switch(_VrtB)\r\n					{\r\n						case \"C\" : _OffsY = -_H / 2; break;\r\n						case \"T\" : _OffsY = 0;       break;\r\n						case \"B\" : _OffsY = -_H;     break;\r\n\r\n						default: \"WTF\";\r\n					}\r\n\r\n					this.AX = iPareB.AX + (iPareB.AW * this.X) + _OffsX;\r\n					this.AY = iPareB.AY + (iPareB.AH * this.Y) + _OffsY;\r\n				}\r\n				\r\n\r\n				\r\n				\r\n\r\n				//this.AX = iPareB.AX + (iPareB.AW * this.X) - (this.AW / 2);\r\n				//this.AY = iPareB.AY + (iPareB.AH * this.Y) - (this.AH / 2);\r\n\r\n\r\n			 },\r\n			\r\n			static : \r\n			 {\r\n				ToJson : function(iObj)\r\n				{\r\n					throw \"ND\";\r\n					oObj = {};\r\n					{\r\n						for(var cMemN in CircleBounds.InstanceFields)\r\n						{\r\n							oObj[cMemN] = CircleBounds[cMemN].Type.ToJson(CircleBounds[cMemN]);\r\n						}\r\n					}\r\n				},\r\n				FromJson : function(iJsonO)\r\n				{\r\n					\r\n				},\r\n			 }\r\n		 },\r\n		'Matrix'             :\r\n		 {\r\n			M11 : num,\r\n			M12 : num,\r\n			M21 : num,\r\n			M22 : num,\r\n			DX  : num,\r\n			DY  : num,\r\n\r\n			constructor     : function Matrix(iM11,iM12,iM21,iM22,iDX,iDY)\r\n			 {\r\n				if(arguments.length == 0)\r\n				{\r\n					this.Reset();\r\n				}\r\n				else if(arguments.length == 6)\r\n				{\r\n					this << iM11;\r\n					this << iM12;\r\n					this << iM21;\r\n					this << iM22;\r\n					this << iDX;\r\n					this << iDY;\r\n				}\r\n				else throw \"Invalid argument count: \" + arguments.length;\r\n			 },\r\n			\r\n			Reset           : function(oM$this)\r\n			 {\r\n				this.M11 = 1;\r\n				this.M12 = 0;\r\n				this.M21 = 0;\r\n				this.M22 = 1;\r\n				this.DX  = 0;\r\n				this.DY  = 0;\r\n\r\n				return this;\r\n			 },\r\n			Multiply        : function(iM$Matrix,oM$this)\r\n			 {\r\n				var _M11 = (this.M11 * iM.M11) + (this.M21 * iM.M12);\r\n				var _M12 = (this.M12 * iM.M11) + (this.M22 * iM.M12);\r\n				var _M21 = (this.M11 * iM.M21) + (this.M21 * iM.M22);\r\n				var _M22 = (this.M12 * iM.M21) + (this.M22 * iM.M22);\r\n				\r\n				var _DX  = (this.M11 * iM.DX)  + (this.M21 * iM.DY) + this.DX;\r\n				var _DY  = (this.M12 * iM.DX)  + (this.M22 * iM.DY) + this.DY;\r\n				\r\n				this.M11 = _M11;\r\n				this.M12 = _M12;\r\n				this.M21 = _M21;\r\n				this.M22 = _M22;\r\n				this.DX  = _DX;\r\n				this.DY  = _DY;\r\n				\r\n				return this;\r\n			 },\r\n			Invert          : function(oM$this)\r\n			 {\r\n				var _D = 1 / (this.M11 * this.M22 - this.M12 * this.M21);\r\n				\r\n				var _M11 = +this.M22 * _D;\r\n				var _M12 = -this.M12 * _D;\r\n				var _M21 = -this.M21 * _D;\r\n				var _M22 = +this.M11 * _D;\r\n				var _DX  = (this.M21 * this.DY - this.M22 * this.DX) * _D;\r\n				var _DY  = (this.M12 * this.DX - this.M11 * this.DY) * _D;\r\n				\r\n				this.M11 = _M11;\r\n				this.M12 = _M12;\r\n				this.M21 = _M21;\r\n				this.M22 = _M22;\r\n				this.DX  = _DX;\r\n				this.DY  = _DY;\r\n				\r\n				return this;\r\n			 },\r\n			Rotate          : function(iRad$num,oM$this)\r\n			 {\r\n				var _Cos = Math.Cos(iRad);\r\n				var _Sin = Math.Sin(iRad);\r\n				\r\n				var _M11 = this.M11 *  _Cos + this.M21 * _Sin;\r\n				var _M12 = this.M12 *  _Cos + this.M22 * _Sin;\r\n				var _M21 = this.M11 * -_Sin + this.M21 * _Cos;\r\n				var _M22 = this.M12 * -_Sin + this.M22 * _Cos;\r\n				\r\n				this.M11 = _M11;\r\n				this.M12 = _M12;\r\n				this.M21 = _M21;\r\n				this.M22 = _M22;\r\n				\r\n				return this;\r\n			 },\r\n			Translate       : function(iX,iY, oM$this)\r\n			 {\r\n				this.DX += this.M11 * iX + this.M21 * iY;\r\n				this.DY += this.M12 * iX + this.M22 * iY;\r\n				\r\n				return this;\r\n			 },\r\n			Scale           : function(iX,iY, oM$this)\r\n			 {\r\n				this.M11 *= iX;\r\n				this.M12 *= iX;\r\n				this.M21 *= iY;\r\n				this.M22 *= iY;\r\n				\r\n				return this;\r\n			 },\r\n			Project         : function(iX,iY, oP$Point)\r\n			 {\r\n				return new Point\r\n				(\r\n					(iX * this.M11) + (iY * this.M21) + this.DX,\r\n					(iX * this.M12) + (iY * this.M22) + this.DY\r\n				)\r\n\r\n				//var oX = iX, oY = iY;\r\n				//{\r\n					//oX = iX * this.M11 + iY * this.M21 + this.DX;\r\n					//oY = iX * this.M12 + iY * this.M22 + this.DY;\r\n				//}\r\n				//return new Point(oX,oY);\r\n			 },\r\n			Unproject       : function(iX,iY, oP$Point)\r\n			 {\r\n				return this.Clone().Invert().Project(iX,iY);\r\n			 },\r\n			\r\n			ProjectVector   : function(iX,iY, oV$Vector)\r\n			 {\r\n				return new Vector\r\n				(\r\n					(iX * this.M11) + (iY * this.M21),\r\n					(iX * this.M12) + (iY * this.M22)\r\n				)\r\n				//var oX = iX, oY = iY;\r\n				//{\r\n					//oX = (iX * this.M11) + (iY * this.M21);\r\n					//oY = (iX * this.M12) + (iY * this.M22);\r\n				//}\r\n				//return new Vector(oX, oY);\r\n			 },\r\n			UnprojectVector : function(iX,iY, oV$Vector){return this.Clone().Invert().ProjectVector(iX,iY);},\r\n			//CurrentScale    : {get : function(oV$num){return Math.Sqrt(Math.Pow(this.M11,2) + Math.Pow(this.M12,2));}},\r\n			CurrentScale    : {get : function(oV$num){return Math.Sqrt((this.M11 * this.M11) + (this.M12 * this.M12))}},\r\n			Clone           : function(){return new Matrix(this.M11, this.M12, this.M21, this.M22, this.DX, this.MDY)},\r\n\r\n			static :\r\n			 {\r\n				Identity : {get once(){return new Matrix()}},\r\n			 }\r\n		 },\r\n	 }\r\n });\r\n",
	"../ClassLibrary/System/GraphicsConsole.chs" : "\"use strict\";\r\n\r\nstuff\r\n ({\r\n	uses :\r\n	[\r\n		'Math',\r\n		//'Math.Geometry',\r\n	],\r\n\r\n	'System.Drawing' :\r\n	 {\r\n		'GraphicsConsole : GraphicsLayer' : \r\n		 {\r\n			Title   : str(\"???\"),\r\n			Enabled : boo(true),\r\n			Lines   : arr(str),\r\n			Columns : arr(num),\r\n			\r\n\r\n			//constructor : function(iAA)\r\n			 //{\r\n				//this.Title   = iAA.Title || null;\r\n				//this.Enabled = true;\r\n				//this.Lines   = [];\r\n			 //},\r\n			UpdateForeground : function()\r\n			 {\r\n				var _Ctx = this.Context;\r\n				{\r\n					_Ctx.ResetTransform();\r\n					//_Ctx.Scale(0.8,0.8);\r\n					_Ctx.TextAlign    = \"left\";\r\n					_Ctx.TextBaseline = \"top\";\r\n					\r\n					//_Ctx.ResetTransform();\r\n					//_Ctx.GlobalAlpha = 1;\r\n\r\n					_Ctx.ClearRect(0, 0, _Ctx.W, _Ctx.H);\r\n				//_Ctx.AddRect(0, 0, _Ctx.W, _Ctx.H, 10);\r\n				//GraphicsLayer.Drawing.DrawBackground(this);\r\n					_Ctx.FillStyle = this.ForeColor;\r\n\r\n				}\r\n\r\n				if(this.Title != undefined)\r\n				{\r\n					_Ctx.Font = \"18px tahoma\";\r\n					_Ctx.FillText(this.Title, 10, 5);\r\n					_Ctx.BeginPath(); _Ctx.MoveTo(10, 30); _Ctx.LineTo(_Ctx.W - 10, 30); _Ctx.Stroke();\r\n					_Ctx.Translate(10, 35);\r\n				}\r\n\r\n				if(true)\r\n				{\r\n					//_Ctx.Font = ;\r\n\r\n					var _CharW = _Ctx.MeasureText(\" \").width;\r\n					\r\n					for(var cL,Li = 0; cL = this.Lines[Li], Li < this.Lines.Length; Li++)\r\n					{\r\n						if(Li * 12 > _Ctx.H) break;\r\n						\r\n						_Ctx.Translate(0,12);\r\n\r\n						_Ctx.FillStyle = this.ForeColor;\r\n						_Ctx.Font      = \"12% courier\";\r\n						\r\n						_Ctx.Save(); switch(typeof(cL))\r\n						{\r\n							case \"object\" :\r\n							{\r\n								if(cL instanceof Array)\r\n								{\r\n									//var _Offs = _Ctx.MeasureStringGraphicsConsole.Drawing.Symbol(_Ctx, \"*\");\r\n									//if(typeof cL[0] == \"string\" && cL[0][0] != \" \") GraphicsConsole.Drawing.Symbol(_Ctx, \"*\")\r\n									\r\n									//_Ctx.Translate(_CharW * 2, 0);\r\n									\r\n									//GraphicsConsole.Drawing.Symbol(_Ctx, \"*\")\r\n									\r\n									//cY += GraphicsConsole.Drawing.Symbol(_Ctx, \"*\", cX, cY).Y;\r\n\r\n									for(var cF,Fi = 0; cF = cL[Fi], Fi < cL.Length; Fi++)\r\n									{\r\n										var cColW = this.Columns[Fi] * _CharW;\r\n										//var cCelW = 0;\r\n										//debugger;\r\n\r\n										if      (typeof(cF) == \"number\")                  GraphicsConsole.Drawing.Number     (_Ctx, cF);\r\n										else if (typeof(cF) == \"boolean\")                 GraphicsConsole.Drawing.Boolean    (_Ctx, cF);\r\n										else if (cF instanceof Math.Geometry.Vector3)     GraphicsConsole.Drawing.Vector3    (_Ctx, cF);\r\n										else if (cF instanceof Math.Geometry.Quaternion)  GraphicsConsole.Drawing.Quaternion (_Ctx, cF);\r\n										else if (typeof(cF) == \"object\")                  GraphicsConsole.Drawing.Object     (_Ctx, cF);\r\n										\r\n										else                                              GraphicsConsole.Drawing.String     (_Ctx, cF);\r\n										//switch(cF.constructor.name)\r\n										//{\r\n											//case \"Vector3\" : break;\r\n											//case \"String\"  : _Ctx.FillText; break;\r\n\r\n											//default : throw \"WTF\";\r\n										//}\r\n										\r\n										//cX += 10;\r\n										//cCelW = Max(cCelW, cColW);\r\n\r\n										//cCelW = Max(cCelW, cColW);\r\n\r\n\r\n										//_Ctx.Translate(cCelW + 10, 0);\r\n										_Ctx.Translate(cColW + 10, 0);\r\n									}\r\n								}\r\n								else throw \"WTF\";\r\n								break;\r\n							}\r\n							case \"number\"  : GraphicsConsole.Drawing.Number  (_Ctx, cL); break;\r\n							case \"boolean\" : GraphicsConsole.Drawing.Boolean (_Ctx, cL); break;\r\n							case \"string\"  : GraphicsConsole.Drawing.String  (_Ctx, cL); break;\r\n\r\n							\r\n							\r\n\r\n							default : throw \"WTF\";\r\n						}\r\n						_Ctx.Restore();\r\n					}\r\n						//if(cL\r\n						//_Ctx.FillText(cL, 10, (Li * 12) + 5);\r\n					\r\n\r\n					//var _Line = []; for(var cC,Ci = 0; cC = arguments[Ci], Ci < arguments.length; Ci++)\r\n					//{\r\n						//switch(typeof(cC))\r\n						//{\r\n							//case \"string\" : _Line.Push({Type : \"String\", Value : cC}); break;\r\n							//case \"object\" :\r\n							//{\r\n								//_Line.Push\r\n									\r\n							//}\r\n						//}\r\n					//}\r\n				}\r\n			 },\r\n			UpdateBackground : function()\r\n			 {\r\n				GraphicsLayer.Drawing.DrawBackground(this);\r\n			 },\r\n			\r\n			Clear       : function()\r\n			 {\r\n				var _IsInvalReq = this.Lines.Length != 0;\r\n\r\n				this.Lines  .Length = 0;\r\n				this.Columns.Length = [];\r\n				\r\n				_IsInvalReq && this.Invalidate();\r\n			 },\r\n			WriteHeader : function(iHeaderS)\r\n			 {\r\n				if(!this.Enabled) return;\r\n				\r\n				this.WriteLine((\"= \" + iHeaderS + \" ====================================================================\").Substring(0, this.Context.W / 7.5));\r\n			 },\r\n			WriteLine   : function(iLineS)\r\n			 {\r\n				if(!this.Enabled) return;\r\n\r\n				if(iLineS == undefined) iLineS = \"\";\r\n\r\n				if(iLineS instanceof Array)\r\n				{\r\n					for(var cF,Fi = 0; cF = iLineS[Fi], Fi < iLineS.Length; Fi++)\r\n					{\r\n						if(cF == undefined)\r\n						{\r\n							iLineS[Fi] = \"UNDEF\";\r\n							continue;\r\n						}\r\n\r\n						var cFieW = cF.Length;\r\n						var cColW = this.Columns[Fi];\r\n\r\n						if(cColW == undefined || (typeof(cF) == \"string\" && cFieW > cColW))\r\n						{\r\n							this.Columns[Fi] = cFieW;\r\n						}\r\n						if(cF.Clone) iLineS[Fi] = cF.Clone(); //~~ Breaks instance links;\r\n					}\r\n				}\r\n				this.Lines.Enqueue(iLineS);\r\n\r\n				while(this.Lines.Length * 12 > this.Context.H - 50) this.Lines.Dequeue(1);\r\n				this.Invalidate();\r\n			 },\r\n			//BeginTable : function()\r\n			 //{\r\n				\r\n			 //},\r\n			//AddRow     : function()\r\n			 //{\r\n				////this.Lines.Push();\r\n				////var _Line = {Text, Fields};\r\n				//var _Line = Array.prototype.clone.call(arguments);\r\n				//this.WriteLine(_Line);\r\n				\r\n				\r\n				\r\n			 //}\r\n			//WriteBorder : function(iLen)\r\n			 //{\r\n				//if(iLen == undefined) iLen = this.MaxLineLength;\r\n				//this.Lines.Push(GraphicsConsole.Border.Substring(0, iLen));\r\n			 //},\r\n			\r\n			\r\n			static : \r\n			{\r\n				Border : \"--------------------------------------------------------------------------------------------------------------------------\",\r\n				Drawing : \r\n				{\r\n					Objects : \r\n					{\r\n					\r\n						Bar : function(iCtx, iObj)\r\n						 {\r\n							var _VV = iObj.Values;\r\n							{\r\n								_VV[0] = _VV[0] == null ? null : _VV[0] / 2 + 0.5;\r\n								_VV[1] = _VV[1] == null ? null : _VV[1] / 2 + 0.5;\r\n								_VV[2] = _VV[2] == null ? null : _VV[2] / 2 + 0.5;\r\n							}\r\n							return this.Bar01(iCtx, iObj);\r\n						 },\r\n						Bar01 : function(iCtx, iObj)\r\n						 {\r\n							var iWidth = iObj.Width || 100;\r\n							var iText  = iObj.Text || \"\";\r\n							\r\n							iCtx.Save();\r\n							iCtx.Translate(+2,+2);\r\n							iCtx.BeginPath(); iCtx.AddRect(0, 0, iWidth, 12);\r\n\r\n							iCtx.FillStyle   = \"#000000\"; iCtx.Fill();\r\n							iCtx.StrokeStyle = \"#ffffff\"; iCtx.Stroke();\r\n\r\n							for(var _VV = iObj.Values, _CC = [\"#ff0000\",\"#00ee00\",\"#00aaff\"], cV,cC,Ci = 0; cV = _VV[Ci], cC = _CC[Ci], Ci < 3; Ci++)\r\n							{\r\n								if(cV == null) continue;\r\n\r\n								if(cV < 0 || cV > 1)\r\n								{\r\n									cV = Clamp01(cV);\r\n\r\n									iCtx.GlobalAlpha = ((Date.Now  - (333 * Ci)) % 1000) < 333 ? 0.5 : 1.0;\r\n								}\r\n\r\n								\r\n\r\n								iCtx.FillStyle = cC;\r\n								iCtx.FillRect(cV * (iWidth - 4), 0, 4, 12);\r\n\r\n								iCtx.GlobalAlpha = 1;\r\n							}\r\n							iCtx.Restore();\r\n							iCtx.FillText(typeof(iText) == \"number\" ? iText.ToString2() : iText,8,0);\r\n\r\n							return;\r\n						 },\r\n						ProgressBar : function(iCtx, iObj)\r\n						 {\r\n						 //return;\r\n							//iObj = {Value : 0.5, TgtValue : 1, Min : -1, Max : +1, Center : 0, ShowDelta : true};\r\n							//iObj.Min       = 0;\r\n							//iObj.Max       = +1;\r\n							//var iMinV = iObj.Min != undefined ? iObj.Min : -1;\r\n							//var iMaxV = iObj.Max != undefined ? iObj.Max : +1;\r\n\r\n							if(iObj.Min    == undefined) iObj.Min = -1;\r\n							if(iObj.Max    == undefined) iObj.Max = +1;\r\n							//if(iObj.Center == undefined) iObj.Center =  = -1;\r\n\r\n							if(iObj.Center == undefined) iObj.Center = (iObj.Min + iObj.Max) / 2;\r\n\r\n							if(iObj.W      == undefined) iObj.W = 100;\r\n							//iObj.ShowDelta = true;\r\n							//var iW = \r\n							\r\n							//{Value : 0.5, TgtValue : 1, Min : -1, Max : +1, Center : 0, ShowDelta : true};\r\n\r\n							//iObj.Min\r\n							//var iCntV  = (iObj.Max + iObj.Min) / 2;\r\n							//var iRange = (iObj.Max - iObj.Min);\r\n							\r\n							var iCurV = Scale01(iObj.CurrValue, iObj.Min, iObj.Max);\r\n							var iCmdV = Scale01(iObj.CommValue, iObj.Min, iObj.Max);\r\n\r\n							//debugger;\r\n							//var Clamp(iObj.Value, iObj.Min, iObj.Max);\r\n							//Clamp(iObj.���Value, iObj.Min, iObj.Max);\r\n\r\n							var iText = iObj.Text; if(iText == undefined) iText = (iObj.CommValue != undefined ? iObj.CommValue : iObj.CurrValue).ToString2();\r\n\r\n\r\n							iCtx.Save();\r\n							iCtx.GlobalAlpha = 1;\r\n							\r\n							iCtx.Translate(+2,+2);\r\n							iCtx.BeginPath(); iCtx.AddRect(0, 0, iObj.W, 12);\r\n\r\n							iCtx.FillStyle   = \"#000000\"; iCtx.Fill();\r\n							iCtx.StrokeStyle = \"#ffffff\"; iCtx.Stroke();\r\n							//iCtx.Translate(Clamp((iObj.Min + iObj.Max) / 2, 0,1),0);\r\n\r\n							\r\n							\r\n\r\n\r\n							\r\n\r\n							//iCtx.FillStyle = \"#ffff00\"; iCtx.FillRect((iCurV * iObj.W), 0, 5, iObj.H);\r\n							iCtx.FillStyle = \"#ff0000\"; iCtx.FillRect((iCurV * (iObj.W - 4)), 0, 4, 12);\r\n							iCtx.FillStyle = \"#00ff00\"; iCtx.FillRect((iCmdV * (iObj.W - 4)), 0, 4, 12);\r\n\r\n							//if(!isNaN(iObj.Center)) iCtx.FillStyle   = \"#cccccc\"; iCtx.FillRect((iObj.Center * iObj.W) + 2, iY + 1, 3, iObj.H);\r\n							//return;\r\n\r\n							//iCtx.FillStyle   = iObj.FillColor || \"#aaaaaa\";\r\n\r\n							////iCtx.FillRect(iX + 2, iY + 1, iObj.W * iCurV, iObj.H);\r\n							//iCtx.FillRect(iX + 2, iY + 1, iObj.W * iCurV, iObj.H);\r\n							\r\n\r\n							////iObj.Min\r\n\r\n							//if(iTgtV != undefined)\r\n							//{\r\n								//iCtx.FillStyle = \"#ffff00\";\r\n								//iCtx.FillRect((iX + (iTgtV * iObj.W)) + 2, iY + 2, 4, iObj.H - 1);\r\n\r\n							//}\r\n							\r\n							iCtx.Restore();\r\n							//iCtx.FillStyle = \"#ffffff\";\r\n							iCtx.FillText(iText,8,0);\r\n							//iCtx.Save();\r\n							//iCtx.Scale(1,0.8);\r\n							\r\n							//iCTx.Restore();\r\n							\r\n							iCtx.GlobalAlpha = 1;\r\n						 },\r\n					},\r\n\r\n					Symbol     : function(iCtx, iStr)\r\n					 {\r\n						iStr += \" \";\r\n\r\n						iCtx.FillText(iStr,0,0);\r\n						return iCtx.MeasureText(iStr).width;\r\n					 },\r\n					String     : function(iCtx, iStr)\r\n					 {\r\n						iCtx.FillText(iStr,0,0);\r\n						return iCtx.MeasureText(iStr).width;\r\n					 },\r\n					Boolean    : function(iCtx, iBoo)\r\n					 {\r\n						iCtx.FillStyle = iBoo ? \"#00cc00\" : \"#ff3300\";\r\n						iCtx.FillRect(-2, +1, 40, 13);\r\n						iCtx.FillStyle = \"#ffffff\";\r\n						iCtx.FillText(iBoo,0,0);\r\n						return 40;\r\n					 },\r\n					Number     : function(iCtx, iNum)\r\n					 {\r\n						var iStr = iNum.ToString2();\r\n\r\n						iCtx.FillText(iStr,0,0);\r\n						return iCtx.MeasureText(iStr).width;\r\n					 },\r\n					Vector3    : function(iCtx, iVec)\r\n					 {\r\n						return this.Quaternion(iCtx, iVec);\r\n\r\n						//var _H = parseInt(iCtx.FontSize);\r\n						////var _VecLen = iVec.Length'\r\n						////de\r\n						////var _X1 = iVec.X;\r\n						//var _Len = iVec.Length, _OpaX = Math.Abs(iVec.X / _Len), _OpaY = Math.Abs(iVec.Y / _Len), _OpaZ = Math.Abs(iVec.Z / _Len);\r\n						\r\n						//iCtx.Save(); iCtx.GlobalAlpha = _OpaX || 0; iCtx.FillStyle = \"#ff0000\";  iCtx.FillRect(iX +   0 - 2, iY + 2, 48, _H); iCtx.Restore(); iCtx.FillText(iVec.X.ToString2(), iX +   0, iY);\r\n						//iCtx.Save(); iCtx.GlobalAlpha = _OpaY || 0; iCtx.FillStyle = \"#00cc00\";  iCtx.FillRect(iX +  50 - 2, iY + 2, 48, _H); iCtx.Restore(); iCtx.FillText(iVec.Y.ToString2(), iX +  50, iY);\r\n						//iCtx.Save(); iCtx.GlobalAlpha = _OpaZ || 0; iCtx.FillStyle = \"#00aaff\";  iCtx.FillRect(iX + 100 - 2, iY + 2, 48, _H); iCtx.Restore(); iCtx.FillText(iVec.Z.ToString2(), iX + 100, iY);\r\n						//iCtx.GlobalAlpha = 1;\r\n\r\n						////iCtx.\r\n						\r\n						////iCtx.StrokeStyle = Colors.White;\r\n						////iCtx.StrokeRect(iX, iY, 100, _H);\r\n						//return 200;\r\n					 },\r\n					Quaternion : function(iCtx, iQua)\r\n					 {\r\n						var _X  = iQua.X,       _AX = Abs(_X),\r\n						    _Y  = iQua.Y,       _AY = Abs(_Y),\r\n						    _Z  = iQua.Z,       _AZ = Abs(_Z),\r\n						    _W  = iQua.W || 0,  _AW = Abs(_W);\r\n							 \r\n						var _Max = Max(_AX,_AY,_AZ,_AW, 1);\r\n\r\n						//var _RX = _AX >= 0.001 ? _AX / _Max : 0,\r\n						    //_RY = _AY >= 0.001 ? _AY / _Max : 0,\r\n							 //_RZ = _AZ >= 0.001 ? _AZ / _Max : 0,\r\n							 //_RW = _AW >= 0.001 ? _AW / _Max : 0;\r\n\r\n						var _RX = _AX / _Max,\r\n						    _RY = _AY / _Max,\r\n							 _RZ = _AZ / _Max,\r\n							 _RW = _AW / _Max;\r\n\r\n						//var _X  = iQua.X,      _Y  = iQua.Y,      _Z  = iQua.Z,      _W  = iQua.W || 0;\r\n						//var _AX = Abs(_X),     _AY = Abs(_Y),     _AZ = Abs(_Z),     _AW = Abs(_W),      _Max = Max(_AX,_AY,_AZ,_AW);\r\n\r\n\r\n						var _H  = parseInt(iCtx.FontSize);\r\n\r\n\r\n					\r\n						if(iQua.X != undefined) {iCtx.Save(); iCtx.GlobalAlpha = _RX || 0; iCtx.FillStyle = \"#ff0000\";  iCtx.FillRect(  0, 2, 48, _H); iCtx.Restore(); iCtx.FillText(_X.ToString2(),   0 + 2, 0);}\r\n						if(iQua.Y != undefined) {iCtx.Save(); iCtx.GlobalAlpha = _RY || 0; iCtx.FillStyle = \"#00cc00\";  iCtx.FillRect( 50, 2, 48, _H); iCtx.Restore(); iCtx.FillText(_Y.ToString2(),  50 + 2, 0);}\r\n						if(iQua.Z != undefined) {iCtx.Save(); iCtx.GlobalAlpha = _RZ || 0; iCtx.FillStyle = \"#00aaff\";  iCtx.FillRect(100, 2, 48, _H); iCtx.Restore(); iCtx.FillText(_Z.ToString2(), 100 + 2, 0);}\r\n						if(iQua.W != undefined) {iCtx.Save(); iCtx.GlobalAlpha = _RW || 0; iCtx.FillStyle = \"#aaaa00\";  iCtx.FillRect(150, 2, 48, _H); iCtx.Restore(); iCtx.FillText(_W.ToString2(), 150 + 2, 0);}\r\n\r\n						iCtx.GlobalAlpha = 1;\r\n\r\n						//iCtx.\r\n						\r\n						//iCtx.StrokeStyle = Colors.White;\r\n						//iCtx.StrokeRect(iX, iY, 100, _H);\r\n						return 200;\r\n					 },\r\n					\r\n					Object     : function(iCtx, iObj)\r\n					 {\r\n						//this.Objects[iObj.Type].ApplyiCtx, iObj);\r\n						this.Objects[iObj.Type](iCtx, iObj);\r\n\r\n						//switch(iObj.Type)\r\n						//{\r\n							//case \"ProgressBar\" :  this.Objects.ProgressBar(iCtx, iObj); break;\r\n							\r\n							//default : \r\n							//{\r\n								//this.String(iCtx, iObj);\r\n							//}\r\n						//}\r\n					 },\r\n				}\r\n			}\r\n		 },\r\n	}\r\n });\r\n",
});