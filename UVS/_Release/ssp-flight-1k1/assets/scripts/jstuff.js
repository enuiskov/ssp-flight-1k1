"use strict";

window.$ = window.stuff = 
{
	list : function(iSrcListO)
	 {
		for(var _FileIds = Object.getOwnPropertyNames(iSrcListO), cFileId,Fi = 0; cFileId = _FileIds[Fi]; Fi++)
		{
			var cFileExt  = cFileId.match(/[^\\\/\.]+$/)[0];
			var cFileData = iSrcListO[cFileId];

			//if(cFileExt == "js")
			{
				try         {Function(cFileData).call()}
				//catch(_Exc) {stuff.load((cFileExt == "chs" ? "../" : "") + cFileId)}
				catch(_Exc) {stuff.load(cFileId)}
			}
		}
	 },
	load : function(iUrl)
	 {
		var _ScrE = document.createElement("SCRIPT");
		{
			_ScrE.src   = iUrl;
			_ScrE.async = false;
		
			_ScrE.onreadystatechange = _ScrE.onload = function(iEvt)
			{
				if(iEvt.type == "load" || (_ScrE.readyState != undefined && _ScrE.readyState.match(/loaded|complete/)))
				{
					
				}
			}
		}
		document.head.appendChild(_ScrE);
	 },
};
stuff.list
({
	"../JStuff/Basis.js" : "\"use strict\";\r\n(function()\r\n{\r\n	var $F,$P,$Mod = function(iF){$F = iF, $P = iF.prototype};\r\n\r\n	$Mod(Object);\r\n	 {\r\n		Object.defineProperties\r\n		 (\r\n			$F,\r\n			{\r\n				Construct : {value : function(iCtorF, iArgA)\r\n				 {\r\n					var oInst = Object.create(iCtorF.prototype); iCtorF.apply(oInst, iArgA);\r\n					return oInst;\r\n				 }},\r\n				GetNode : {value : function(iSrcO, iPath)\r\n				 {\r\n					for(var _LL = iPath.Split('/'), cO,pO = iSrcO, cL,Li = 0; cL = _LL[Li], cO = pO[cL], Li < _LL.Length; Li++, pO = cO)\r\n					{\r\n						if(cO == undefined)      throw \"Node '\" + iPath + \"' not found in '\" + this + \"'\";\r\n						if(Li == _LL.Length - 1) return cO;\r\n					}\r\n				 }},\r\n				SetNode : {value : function(iPath, iValue){throw \"NI\"}},\r\n				Select  : {value : function(iPath){throw \"NI\"}},\r\n			}\r\n		 );\r\n		Object.defineProperties\r\n		 (\r\n			$P,\r\n			{\r\n				ValueOf  : {value : $P.valueOf,  configurable : true, writable : true},\r\n				ToString : {value : $P.toString, configurable : true, writable : true},\r\n				//ToSource : {value : $P.toSource, configurable : true, writable : true},\r\n\r\n				//IsOneOf :\r\n				//{\r\n					//value : function()\r\n					//{\r\n						//for(var cA,Ai = 0; cA = arguments[Ai], Ai < arguments.length; Ai++)\r\n						//{\r\n							//if(this == cA) return true;\r\n						//}\r\n						//return false;\r\n					//}\r\n				//},\r\n			}\r\n		 );\r\n	 }\r\n	$Mod(Array);\r\n	 {\r\n		$F.FromArguments = function(iArgsO)\r\n		 {\r\n			var oArray = [];\r\n			{\r\n				for(var Ai = 0; Ai < iArgsO.length; Ai++)\r\n				{\r\n					oArray[Ai] = iArgsO[Ai];\r\n				}\r\n			}\r\n			return oArray;\r\n		 };\r\n		Object.defineProperties\r\n		 (\r\n			$P,\r\n			{\r\n				Length    : {get : function(){return this.length;}, set : function(iV){this.length = iV;}, enumerable : false},\r\n\r\n				Push      : {value : $P.push},\r\n				Pop       : {value : $P.pop},\r\n				Sort      : {value : $P.sort},\r\n				Filter    : {value : $P.filter},\r\n				ForEach   : {value : $P.forEach},\r\n				Map       : {value : $P.map},\r\n				\r\n				Concat    : {value : $P.concat},\r\n				Slice     : {value : $P.slice},\r\n				Clone     : {value : $P.slice},\r\n				Clear     : {value : function(){this.length = 0}},\r\n\r\n				Contains  : {value : function(iS){return this.indexOf(iS) != -1}},\r\n\r\n				Add       : {value : $P.push},\r\n				AddRange  : {value : function(iII){for(var cI,Ii = 0; cI = iII[Ii], Ii < iII.length; Ii++) this.Add(cI); return this}},\r\n				Remove    : {value : function(iItem){return this.RemoveAt(this.indexOf(iItem))}},\r\n				RemoveAt  : {value : function(iIndex)\r\n				 {\r\n					var _Bef = this.slice(0, iIndex);\r\n					var _Aft = this.slice(iIndex + 1, this.length);\r\n					\r\n					this.length = 0;\r\n\r\n					this.AddRange(_Bef);\r\n					this.AddRange(_Aft);\r\n				 }},\r\n				Enqueue   : {value : $P.push},\r\n				Dequeue   : {value : $P.shift},\r\n			}\r\n		 );\r\n	 }\r\n	$Mod(String);\r\n	 {\r\n		Object.defineProperties\r\n		(\r\n			$P,\r\n			{\r\n				ToString : {value : $P.toString},\r\n\r\n				Length       : {get : function(){return this.length;}, enumerable : false},\r\n\r\n				Substring    : {value : $P.substring},\r\n				Trim         : {value : $P.trim},\r\n				TrimStart    : {value : undefined},\r\n				TrimEnd      : {value : undefined},\r\n				IndexOf      : {value : $P.indexOf},\r\n				LastIndexOf  : {value : $P.lastIndexOf},\r\n\r\n				Replace      : {value : $P.replace},\r\n				Split        : {value : $P.split},\r\n\r\n				Contains     : {value : function(iS){return this.indexOf(iS) != -1;}},\r\n\r\n				StartsWith   : {value : function(iS){return this.substring(0,iS.length) == iS;}},\r\n				EndsWith     : {value : function(iS){return this.substring(this.length - iS.length, this.length) == iS;}},\r\n\r\n				ToLower      : {value : $P.toLowerCase},\r\n				ToUpper      : {value : $P.toUpperCase},\r\n			}\r\n		);\r\n	 }\r\n	$Mod(Number);\r\n	 {\r\n		Object.defineProperties\r\n		(\r\n			$P,\r\n			{\r\n				ToFixed   : {value : $P.toFixed},\r\n				ToString  : {value : $P.toString},\r\n				ToString2 : {value : function(iMaxDigits, iDoShowSign)\r\n				 {\r\n					if(iMaxDigits  == undefined) iMaxDigits = 3;\r\n					if(iDoShowSign == undefined) iDoShowSign = true;\r\n\r\n					var _ScaV = Math.pow(10, iMaxDigits);\r\n\r\n					var _AbsV = Math.abs(Math.round(this * _ScaV) / _ScaV);   //~~   300.1415;\r\n					var _AbsS = _AbsV.toFixed(iMaxDigits);                    //~~  \"300.141\";\r\n					\r\n					var _IntV = Math.floor(_AbsV);                            //~~   300;\r\n					var _IntS = _IntV.toString();                             //~~  \"300\";\r\n					var _FraS = _AbsS.substring(_IntS.length - 1);            //~~  \"0.141\";\r\n					\r\n					var _Sign = this >= 0 ? \"+\" : \"-\";                        //~~  \"+\" | \"-\";\r\n\r\n					var oStr  = \"\";\r\n					{\r\n						if(iDoShowSign) oStr += _Sign;\r\n\r\n						if(_AbsV < _ScaV * 100)\r\n						{\r\n							oStr += _IntS;\r\n							\r\n							if(iMaxDigits != 0 && _IntS.length < iMaxDigits + 1)\r\n							{\r\n								oStr +=  \".\" + _FraS.substr(2, Math.max(_FraS.length - _IntS.length - 1, 0));\r\n							}\r\n						}\r\n						else\r\n						{\r\n							oStr += _AbsV.toExponential(Math.max(iMaxDigits - 2, 0));\r\n						}\r\n					}\r\n					return oStr;\r\n				 }},\r\n			}\r\n		);\r\n	 }\r\n	\r\n	$Mod(Function);\r\n	 {\r\n		Object.defineProperties\r\n		(\r\n			$P,\r\n			{\r\n				Apply    : {value : $P.apply},\r\n				Bind     : {value : $P.bind},\r\n				Call     : {value : $P.call},\r\n				\r\n				ToString : {value : $P.toString},\r\n			}\r\n		);\r\n\r\n	 }\r\n	$Mod(Date);\r\n	 {\r\n		Object.defineProperties\r\n		 (\r\n			$F,\r\n			{\r\n				Create : {value : function(iYea,iMon,iDay, iHou,iMin,iSec, iMilS)\r\n				 {\r\n					if(iYea == undefined) iYea = 1957;\r\n					if(iMon == undefined) iMon = 1;\r\n					if(iDay == undefined) iDay = 1;\r\n\r\n					if(iHou == undefined) iHou = 0;\r\n					if(iMin == undefined) iMin = 0;\r\n					if(iSec == undefined) iSec = 0;\r\n					if(iMiS == undefined) iMiS = 0;\r\n\r\n\r\n					return new Date(iYea,iMon-1,iDay, iHou,iMin,iSec, iMilS);\r\n				 }},\r\n				Now    : {get : function(){return new Date()}},\r\n				Today  : {get : function(){var _D = new Date(); return new Date(_D.getYear(),_D.getMonths(),_D.getDate())}},\r\n			}\r\n		 );\r\n		Object.defineProperties\r\n		 (\r\n			$P,\r\n			{\r\n				ValueOf         : {value : $P.valueOf},\r\n				ToString        : {value : $P.toString},\r\n				ToString2       : {value : function(iFormat)\r\n				{\r\n					if(!iFormat) iFormat = \"yyyy-MM-dd HH:mm:ss\";\r\n\r\n					switch(iFormat)\r\n					{\r\n						//case \"yyyy-MM-dd HH:mm:ss\" : return this.Year + \"-\" + this.Month\r\n						default : throw \"Time string format not supported\";\r\n					}\r\n				}},\r\n				Year            : {get : function(){return this.getFullYear     ()},     set : function(iV){this.setFullYear     (iV)}},\r\n				Month           : {get : function(){return this.getMonth        () + 1}, set : function(iV){this.setMonth        (iV - 1)}},\r\n				Day             : {get : function(){return this.getDate         ()},     set : function(iV){this.setDate         (iV)}},\r\n				Hour            : {get : function(){return this.getHours        ()},     set : function(iV){this.setHours        (iV)}},\r\n				Minute          : {get : function(){return this.getMinutes      ()},     set : function(iV){this.setMinutes      (iV)}},\r\n				Second          : {get : function(){return this.getSeconds      ()},     set : function(iV){this.setSeconds      (iV)}},\r\n				Millisecond     : {get : function(){return this.getMilliseconds ()},     set : function(iV){this.setMilliseconds (iV)}},\r\n\r\n				Ticks           : {get : function(){return this.valueOf()}},\r\n				DayOfWeek       : {get : function(){throw \"NI\"}},\r\n				DayOfYear       : {get : function(){throw \"NI\"}},\r\n				TimeOfDate      : {get : function(){throw \"NI\"}},\r\n\r\n				AddYears        : {value : function(iV){return new Date(new Date(this.valueOf()).setFullYear     (this.getFullYear     () + iV))}},\r\n				AddMonths       : {value : function(iV){return new Date(new Date(this.valueOf()).setMonth        (this.getMonth        () + iV))}},\r\n				AddWeeks        : {value : function(iV){return new Date(new Date(this.valueOf()).setDate         (this.getDate         () + iV * 7))}},\r\n				AddDays         : {value : function(iV){return new Date(new Date(this.valueOf()).setDate         (this.getDate         () + iV))}},\r\n				AddHours        : {value : function(iV){return new Date(new Date(this.valueOf()).setHours        (this.getHours        () + iV))}},\r\n				AddMinutes      : {value : function(iV){return new Date(new Date(this.valueOf()).setMinutes      (this.getMinutes      () + iV))}},\r\n				AddSeconds      : {value : function(iV){return new Date(new Date(this.valueOf()).setSeconds      (this.getSeconds      () + iV))}},\r\n				AddMilliseconds : {value : function(iV){return new Date(new Date(this.valueOf()).setMilliseconds (this.getMilliseconds () + iV))}},\r\n			}\r\n		 );\r\n	 }\r\n	$Mod(Math);\r\n	 {\r\n		$F.D090   = $F.PI / 2;\r\n		$F.D180   = $F.PI;\r\n		$F.D270   = $F.PI * 1.5;\r\n		$F.D360   = $F.PI * 2;\r\n		$F.RTD    = 180 / $F.PI;\r\n		$F.DTR    = 1 / $F.RTD;\r\n\r\n		$F.Max    = $F.max;\r\n		$F.Min    = $F.min;\r\n\r\n		$F.Sqrt   = $F.sqrt;\r\n		$F.Abs    = $F.abs;\r\n		\r\n		$F.Sin    = $F.sin;\r\n		$F.Cos    = $F.cos;\r\n		$F.Asin   = $F.asin;\r\n		$F.Acos   = $F.acos;\r\n		$F.Tan    = $F.tan;\r\n		$F.Atan   = $F.atan;\r\n		$F.Atan2  = $F.atan2;\r\n\r\n		$F.Exp    = $F.exp;\r\n\r\n		$F.Ceil   = $F.ceil;\r\n		$F.Floor  = $F.floor;\r\n\r\n		$F.Imul   = $F.imul;\r\n		$F.Log    = function(iV, iBase){return iBase == undefined ? Math.log(iV) : Math.log(iV) / Math.log(iBase)};\r\n		$F.Log10  = function(iV){return Math.log(iV) / Math.log(10)};\r\n		$F.LogN   = function(iV){return Math.log(iV)};\r\n		$F.Pow    = $F.pow;\r\n		\r\n		$F.Magic  = function(iV, iPower){return Math.pow(Math.abs(iV), 1 / iPower) * (iV > 0 ? +1 : -1)},\r\n		\r\n\r\n		$F.Round  = $F.round;\r\n		$F.Random = $F.random;\r\n\r\n\r\n		$F.Round  = function(iValue, iDigits)\r\n		 {\r\n			if(iDigits)\r\n			{\r\n				return Math.round(iValue * Math.pow(10, iDigits)) / Math.pow(10, iDigits);\r\n			}\r\n			else return Math.round(iValue);\r\n		 };\r\n		$F.Sign   = function(iNum)\r\n		 {\r\n			return isNaN(iNum) ? NaN : (iNum == 0 ? 0 : (iNum > 0 ? +1 : -1));\r\n		 };\r\n		\r\n		$F.Avg       = function(iVV)\r\n		 {\r\n			if(arguments.length > 1) iVV = arguments;\r\n			\r\n			var _VVs = NaN;\r\n			var _VVc = 0;\r\n			\r\n			for(var cV,Vi = 0; cV = iVV[Vi], Vi < iVV.length; Vi++)\r\n			{\r\n				if(!isNaN(cV))\r\n				{\r\n					if(isNaN(_VVs)) _VVs = 0;\r\n					\r\n					_VVs += cV;\r\n					_VVc ++;\r\n				}\r\n			}\r\n			return _VVs / _VVc;\r\n		 };\r\n		$F.Mix       = function(ixV,iyV, iA){return (ixV * (1 - iA)) + (iyV * iA)};\r\n\r\n		$F.Clamp    = function(iNum, iMin_Max, iMax)\r\n		 {\r\n			if(isNaN(iNum)) return NaN;\r\n\r\n			var iMin;\r\n			{\r\n				if(iMax == undefined)\r\n				{\r\n					if     (iMin_Max == undefined) iMin_Max = 1;\r\n\r\n					iMin = -iMin_Max;\r\n					iMax = +iMin_Max;\r\n				}\r\n				else iMin = iMin_Max;\r\n			}\r\n			if(iMin > iMax) throw new Error(\"ARGS: invalid range bounds\");\r\n			\r\n			return Math.Min(Math.Max(iNum, iMin), iMax);\r\n		 };\r\n		$F.Clamp01  = function(iNum){return Math.Clamp(iNum, 0,1)};\r\n		\r\n		$F.Scale    = function(iNum, iMin_Max, iMax){return Math.Scale01(iNum, iMin_Max, iMax) * 2 - 1};\r\n		$F.Scale01  = function(iNum, iMin_Max, iMax)\r\n		 {\r\n			if(isNaN(iNum)) return NaN;\r\n\r\n			var iMin;\r\n			{\r\n				if(iMax == undefined)\r\n				{\r\n					if     (iMin_Max == undefined) iMin_Max = 1;\r\n					//else if(iMin_Max < 0)          throw \"ARGS: positive value expected\";\r\n\r\n					iMin = -iMin_Max;\r\n					iMax = +iMin_Max;\r\n				}\r\n				else iMin = iMin_Max;\r\n			}\r\n			return (iNum - iMin) / (iMax - iMin);\r\n		 };\r\n		$F.DegToRad  = function(iDegs){return iDegs * Math.DTR};\r\n		$F.RadToDeg  = function(iRads){return iRads * Math.RTD};\r\n		$F.Angle     = function(iFrA, iToA){var _ClwsA = (iToA % Math.D360) - (iFrA % Math.D360), _AbsA = Math.Abs(_ClwsA); return _AbsA > Math.D180 ? (_AbsA - Math.D360) * Math.Sign(_ClwsA) : _ClwsA};\r\n	 }\r\n	$Mod(RegExp);\r\n	 {\r\n		$F.Escape = function(iStr)\r\n		{\r\n			throw \"NI\";\r\n		};\r\n	 }\r\n	$Mod(CanvasRenderingContext2D);\r\n	 {\r\n		Object.defineProperties\r\n		(\r\n			$P,\r\n			{\r\n				Clear         : {value : function(){this.ClearRect(0,0,this.W,this.H)}},\r\n				ClearRect     : {value : $P.clearRect},\r\n				Clip          : {value : $P.clip},\r\n				AddRect       : {value : function(iX, iY, iW, iH, iR)\r\n				 {\r\n					if(iR != undefined)\r\n					{\r\n						if (iW < 2 * iR) iR = iW / 2;\r\n						if (iH < 2 * iR) iR = iH / 2;\r\n						\r\n						this.moveTo		(iX + iR,   iY);\r\n						this.arcTo		(iX + iW,   iY,        iX + iW,   iY + iH,   iR);\r\n						this.arcTo		(iX + iW,   iY + iH,   iX,        iY + iH,   iR);\r\n						this.arcTo		(iX,        iY + iH,   iX,        iY,        iR);\r\n						this.arcTo		(iX,        iY,        iX + iW,   iY,        iR);\r\n						this.closePath	();\r\n					}\r\n					else\r\n					{\r\n						this.rect(iX,iY,iW,iH);\r\n					}\r\n				 }},\r\n				AddCircle     : {value : function(iX, iY, iR)\r\n				 {\r\n					this.moveTo (iX + iR, iY);\r\n					this.arc    (iX,iY,iR, 0, Math.PI * 2);\r\n				 }},\r\n				//AddCircle     : {value : function(iX, iY, iR)\r\n				 //{\r\n					\r\n					//this.moveTo (iX, (iY - iR));\r\n\r\n					//this.arcTo(iX + iR, iY - iR,  iX + iR, iY + iR,  iR);\r\n					//this.arcTo(iX + iR, iY + iR,  iX - iR, iY + iR,  iR);\r\n					//this.arcTo(iX - iR, iY + iR,  iX - iR, iY - iR,  iR);\r\n					//this.arcTo(iX - iR, iY - iR,  iX + iR, iY - iR,  iR);\r\n\r\n					//this.closePath	();\r\n				 //}},\r\n				AddArc        : {value : $P.arc},\r\n				//AddPie        : {value : function(iX, iY, iR, iFrac, iRot)\r\n				 //{\r\n					//if(iRot == undefined) iRot = 0;\r\n\r\n					//throw \"NI\";\r\n					////this.moveTo (iX, (iY - iR));\r\n\r\n					////this.arcTo(iX + iR, iY - iR,  iX + iR, iY + iR,  iR);\r\n					////this.arcTo(iX + iR, iY + iR,  iX - iR, iY + iR,  iR);\r\n					////this.arcTo(iX - iR, iY + iR,  iX - iR, iY - iR,  iR);\r\n					////this.arcTo(iX - iR, iY - iR,  iX + iR, iY - iR,  iR);\r\n\r\n					////this.closePath	();\r\n				 //}},\r\n				Stroke        : {value : $P.stroke},\r\n				Fill          : {value : $P.fill},\r\n\r\n				BeginFrame    : {value : function(){if(this.W != undefined && this.H != undefined) this.ClearRect(0,0,this.W,this.H); }},\r\n				BeginPath     : {value : $P.beginPath},\r\n				ClosePath     : {value : $P.closePath},\r\n				\r\n				StrokeRect    : {value : $P.strokeRect},\r\n				FillRect      : {value : $P.fillRect},\r\n\r\n				MoveTo        : {value : $P.moveTo},\r\n				LineTo        : {value : $P.lineTo},\r\n				ArcTo         : {value : $P.arcTo},\r\n				\r\n				Font          : {get : function(){return this.font;}, set : function(iV){this.font         = iV;}},\r\n				FontSize      : {get : function(){return this.font.match(/^\\d+\\S+/).toString();}, set : function(iV){this.font = this.font.replace(/[\\d\\.]+[\\w%]*/, iV);}},\r\n				FontWeight    : {set : function(iV){this.font = this.font.replace(/^(normal|bold|italic)\\s*|^/, iV + \" \");}},\r\n\r\n				TextAlign     : {get:function(){return this.textAlign;},    set:function(iV){this.textAlign    = iV;}},\r\n				TextBaseline  : {get:function(){return this.textBaseline;}, set:function(iV){this.textBaseline = iV;}},\r\n\r\n				StrokeText    : {value : $P.strokeText},\r\n				FillText      : {value : $P.fillText},\r\n				MeasureText   : {value : $P.measureText},\r\n				\r\n				LineWidth     : {get:function(){return this.lineWidth;},   set:function(iV){this.lineWidth = iV;}},\r\n				\r\n				StrokeStyle   : {get:function(){return this.strokeStyle;}, set:function(iV){ this.strokeStyle = typeof(iV) == \"string\" || iV instanceof CanvasGradient ? iV : iV.AsString;}},\r\n				FillStyle     : {get:function(){return this.fillStyle;},   set:function(iV){ this.fillStyle   = typeof(iV) == \"string\" || iV instanceof CanvasGradient ? iV : iV.AsString;}},\r\n				\r\n				GlobalAlpha   : {get:function(){return this.globalAlpha;}, set:function(iV){ this.globalAlpha = iV;}},\r\n				GlobalCompositeOperation  : {get:function(){return this.globalCompositeOperation;}, set:function(iV){this.globalCompositeOperation = iV;}},\r\n\r\n\r\n				Save          : {value : $P.save},\r\n				Restore       : {value : $P.restore},\r\n\r\n				UpdateSize    : {value : function(){this.W = this.canvas.width; this.H = this.canvas.height; this.canvas.style.fontSize=\"100px\"; }},\r\n\r\n				//ZoomIn        : {value : function(iWScalar, iHScalar){if( this.IsZoomed) throw \"WTF: Already zoomed in?\"; this.IsZoomed = true;  this.Save(); this.Scale(this.W * iWScalar||1, this.H * iHScalar||1);}},\r\n				ZoomIn        : {value : function(iWidF, iHeiF)\r\n				 {\r\n					if(this.IsZoomed) throw \"WTF: Already zoomed in?\";\r\n\r\n					if     (!iWidF && !iHeiF) iWidF = 1, iHeiF = 1;\r\n					else if(!iWidF &&  iHeiF) iWidF = iHeiF * (this.W / this.H);\r\n					else if( iWidF && !iHeiF) iHeiF = iWidF * (this.H / this.W);\r\n\r\n					this.Save();\r\n\r\n					this.ZoomIn.UnzoomData = {W : this.W, H : this.H};\r\n					this.Scale(this.W / iWidF, this.H / iHeiF);\r\n\r\n					this.W = iWidF; this.H = iHeiF;\r\n				 }},\r\n				ZoomOut       : {value : function(){var _UnZ = this.ZoomIn.UnzoomData; if(!_UnZ) throw \"WTF: context is not zoomed in\"; this.Restore(); this.W = _UnZ.W; this.H = _UnZ.H; this.ZoomIn.UnzoomData = undefined;}},\r\n				\r\n				Translate            : {value : $P.translate},\r\n				Rotate               : {value : $P.rotate},\r\n				Scale                : {value : $P.scale},\r\n\r\n				Transform            : {value : $P.transform},\r\n				SetTransform         : {value : $P.setTransform},\r\n				ResetTransform       : {value : function(){this.SetTransform(1,0,0,1,0,0);}},\r\n				\r\n				CreateLinearGradient : {value : $P.createLinearGradient},\r\n\r\n				DrawFramerate        : {value : function()\r\n				 {\r\n					var _CurrRate = 1000 / Math.max(new Date() - this.LastDrawTime, 1);\r\n					\r\n					var _AvgRateToShow;\r\n					{\r\n						if(isNaN(this.AverageRate)) this.AverageRate = _CurrRate;\r\n						//this.AverageRate = _CurrRate < 10 ? _CurrRate : this.AverageRate + (_CurrRate - this.AverageRate) / _CurrRate * 10;\r\n						if(_CurrRate >= 10)         this.AverageRate = this.AverageRate + (_CurrRate - this.AverageRate) / _CurrRate * 10;\r\n						if(this.AverageRate < 0)    this.AverageRate = 0;\r\n\r\n						_AvgRateToShow = this.AverageRate;\r\n					}\r\n					this.LastDrawTime = new Date();\r\n					\r\n					var _BackColor, _ForeColor;\r\n					{\r\n						if(_AvgRateToShow >= 1000)\r\n						{\r\n							_AvgRateToShow = \" ERR\";\r\n							_BackColor     = \"#000000\";\r\n							_ForeColor     = \"#ffffff\";\r\n						}\r\n						else\r\n						{\r\n							var _V = Math.floor(Math.min(_AvgRateToShow / 10 * 255, 255));\r\n							_BackColor = \"rgb(255,\" + _V + \",\" + _V + \")\";\r\n							_ForeColor = _V < 64 ? \"#ffffff\" : \"#000000\";\r\n						}\r\n					}\r\n					var _Ctx = this;\r\n					{\r\n						_Ctx.ResetTransform();\r\n						_Ctx.Font = \"18px tahoma\";\r\n						_Ctx.TextAlign = \"left\";\r\n						\r\n						_Ctx.LineWidth = 1;\r\n						_Ctx.FillStyle = _BackColor;\r\n						_Ctx.StrokeStyle = \"#000000\";\r\n						\r\n						_Ctx.BeginPath();\r\n						_Ctx.AddRect(10, this.canvas.height - 36, 58, 25, 5);\r\n\r\n						\r\n						_Ctx.Fill();\r\n						\r\n						\r\n						_Ctx.Stroke();\r\n						\r\n						_Ctx.FillStyle = _ForeColor;\r\n						_Ctx.FillText(typeof(_AvgRateToShow) == \"string\" ? _AvgRateToShow : _AvgRateToShow.ToString2(3,false), 16, _Ctx.canvas.height - 17);\r\n					}\r\n				 }},\r\n			}\r\n		);\r\n	 };\r\n	$Mod(CanvasGradient);\r\n	 {\r\n		Object.defineProperties\r\n		(\r\n			$P,\r\n			{\r\n				AddColorStop         : {value : $P.addColorStop},\r\n			}\r\n		);\r\n	 }\r\n})();\r\n\r\nvar $dom = function(iElemId){return document.getElementById(iElemId)};\r\n// );\r\n",
	"../JStuff/Core.js" : "\"use strict\";\r\n\r\nwindow.onerror = function(iMsg,iUrl,iLineN)\r\n {\r\n	if(!stuff.IsRuntimeState)\r\n	{\r\n		stuff.IsFailedState = true;\r\n		stuff.AddMessage(stuff.MessageType.FatalError, \"JSERRORS\", iMsg, undefined, iUrl, iLineN, false);\r\n	}\r\n };\r\nwindow.onload  = function()\r\n {\r\n	if(!stuff.IsInitComplete && stuff.Requests.length == 0) stuff.init();\r\n };\r\nObject.defineProperties\r\n (\r\n	window,\r\n	{\r\n		jso  : {value : function _jso  (iJsO)     {return function _jso(){return iJsO;}}},\r\n		any  : {value : function _any  ()         {return function _any(){}}},\r\n		enm  : {value : function _enm  ()         {return function _enm(){}}},\r\n		fnc  : {value : function _fnc  ()         {return function _fnc(){}}},\r\n		arr  : {value : function _arr  (iType)    {return function _arr(){}}},\r\n		num  : {value : function _num  (iV)       {return function _num(){return iV}}},\r\n		str  : {value : function _str  (iV)       {return function _str(){return iV}}},\r\n		boo  : {value : function _boo  (iV)       {return function _boo(){return iV}}},\r\n		rgx  : {value : function _rgx  (iV)       {return function _rgx(){return iV}}},\r\n		obj  : {value : function _obj  (iObj)     {var _CtorAA = arguments; return function _obj(i1,i2){return {ObjOrAlias : iObj, Args : _CtorAA}}}},\r\n		nil  : {value : function _nil  (iPath)    {return function _nil(i1,i2){return {Path : iPath}}}},\r\n		\r\n		self : {value : 1.016104909293719e-21},\r\n	}\r\n );\r\n//window.$ = window.stuff = function(){};\r\n{\r\n	$.IsTransformedState         = false;     //~~ ;\r\n	$.IsInitComplete             = false;     //~~ To avoid second $.init() call in window.onload handler;\r\n	$.IsFailedState              = false;     //~~ ;\r\n	$.IsRuntimeState             = false;     //~~ ;\r\n	$.CurrentFile                = undefined; //~~ ;\r\n	$.CurrentPack                = undefined; //~~ ;\r\n	$.CurrentItem                = undefined; //~~ ;\r\n	$.LastClassIndex             = -1;        //~~ Base class reference index used in 'this.overriden' substitutions;\r\n	$.OnLoad                     = undefined; //~~ Can be called when no entry point was defined;\r\n\r\n	$.Config                     = new function Config()\r\n	 {\r\n		this.InlayRgx     = new RegExp(\"^_[_a-z]+$\");\r\n		this.ValTypeRgx   = new RegExp(\"^number|string|boolean$\");\r\n		this.SelfRgx      = new RegExp(\"(\\\\D)\" + self + \"(\\\\D)\", \"g\");\r\n		\r\n		this.IdentRgx     = new RegExp(/[~\\w][\\w\\d]*/);\r\n		this.PathRgx      = new RegExp(\"(?:\" + this.IdentRgx.source + \"\\\\s*\\\\.\\\\s*)*(\" + this.IdentRgx.source + \")\");\r\n		this.NameOnlyRgx  = new RegExp(\"\" + this.IdentRgx.source + \"$\");\r\n		\r\n		this.ParentRgx    = new RegExp(\"^(?:(.+?)\\\\.)?\" + this.IdentRgx.source + \"$\");\r\n		this.DeclaRgx     = new RegExp(\"^\\\\s*(\" + this.PathRgx.source + \")\\\\s*(?:\\\\:\\\\s*(\" + this.PathRgx.source + \"))?\\\\s*$\");\r\n\r\n		this.AssignRgx    = new RegExp(\"(o\" + this.IdentRgx.source + \")\\\\s*<<\\\\s*(\" + this.PathRgx.source + \")\\\\s*\\\\|\\\\|\\\\s*([^;]*);\", \"g\"); \r\n		\r\n		this.ThisArgRgx1  = new RegExp(\"this\\\\s*<<\\\\s*i(\" + this.IdentRgx.source + \")\\\\s*\\\\|\\\\|\\\\s*([^;]+)\\\\s*;\", \"g\");\r\n		this.ThisArgRgx2  = new RegExp(\"this\\\\s*<<\\\\s*i(\" + this.IdentRgx.source + \")\\\\s*;\", \"g\");\r\n		this.ThisArgRgx3  = new RegExp(\"this\\\\s*<<\\\\s*(\" + this.PathRgx.source + \")\\\\s*\\\\|\\\\|\\\\s*([^;]+)\\\\s*;\", \"g\");\r\n		this.ThisArgRgx4  = new RegExp(\"this\\\\s*<<\\\\s*(\" + this.PathRgx.source + \")\\\\s*;\", \"g\");\r\n		\r\n		//~~ Is used in \"this << iAA.FieldName || error\";\r\n		this.ErrorArgRgx1 = new RegExp(\"\\\\((\" + this.PathRgx.source + \") !== undefined \\\\? \\\\2 :\\\\) error\\\\s*\\\\((\\\".*?\\\")\\\\)\\\\s*;\", \"g\");\r\n		this.ErrorArgRgx2 = new RegExp(\"\\\\((\" + this.PathRgx.source + \") !== undefined \\\\? \\\\2 :\\\\) error\\\\s*;\", \"g\");\r\n	 };\r\n	$.ObjectType                 =\r\n	 {\r\n		Undefined    : \"Undefined\"   , //~~ MemberName  : undefined;\r\n\r\n		Object       : \"Object\"      , //~~ ;\r\n		Value        : \"Value\"       , //~~ MemberName  : 5;\r\n		\r\n		Array        : \"Array\"       , //~~ MemberName  : [1,2,3];\r\n\r\n		Namespace    : \"Namespace\"   , //~~ NsName      : {...};\r\n		Class        : \"Class\"       , //~~ 'ClassName : ParentName' : {};\r\n		Instance     : \"Instance\"    , //~~ instance    : {};\r\n		Static       : \"Static\"      , //~~ static      : {};\r\n		Field        : \"Field\"       , //~~ FieldName   : num | num(1);\r\n		Function     : \"Function\"    , //~~ FuncName    : function(){};\r\n		Method       : \"Method\"      , //~~ MethodName  : function(){};\r\n		\r\n		Constructor  : \"Constructor\" , //~~ constructor : function(){};\r\n		Initializer  : \"Initializer\" , //~~ initializer : function(){};\r\n\r\n		Property     : \"Property\"    , //~~ Property    : {get : function(oV){}, set : function(iV){}};\r\n		Oncer        : \"Oncer\"       , //~~ Oncer       : {get once(){return DoSomethingJustOnce()}};\r\n		JsObject     : \"JsObject\"    , //~~ JsObject    : jso ({...});\r\n	 };\r\n	$.MessageType                =\r\n	 {\r\n		Notification : \"Notification\",\r\n		Tip          : \"Tip\"         ,\r\n		Warning      : \"Warning\"     ,\r\n		Error        : \"Error\"       ,\r\n		FatalError   : \"FatalError\"  ,\r\n	 };\r\n	\r\n	$.SourceList                 = {}; //~~ 'embedded' SourceList that do not require additional requests;\r\n	$.Requests                   = []; \r\n	$.Files                      = {}; \r\n	$.Nodes                      = {}; \r\n	$.EntryPoints                = []; \r\n	\r\n	\r\n	$.File                       = function(iUrl, iSource, iCompiled)\r\n	 {\r\n		this.Url      = iUrl;\r\n		this.Name     = iUrl.match(/([^\\/]*)$/)[1];\r\n		this.Source   = iSource;\r\n		this.Compiled = iCompiled;\r\n		this.Packs    = [];\r\n	 };\r\n	$.Pack                       = function(iUrl, iTreeO, iCloseF)\r\n	 {\r\n		$.CurrentPack = this;\r\n		\r\n		this.File      = $.Files[iUrl];\r\n		this.Uses      = iTreeO[\"uses\"]; delete iTreeO[\"uses\"];\r\n		this.Init      = iTreeO[\"init\"]; delete iTreeO[\"init\"];\r\n		this.Main      = iTreeO[\"main\"]; delete iTreeO[\"main\"];\r\n\r\n		this.Structure = iTreeO;\r\n		this.Items     = $.Routines.FlattenItems(iTreeO, \"\", this);\r\n		this.Close     = function(){iCloseF.call(null, this.Closures)}.bind(this);\r\n	 };\r\n	$.Node                       = function(iId, iII)\r\n	 {\r\n		this.ID       = iId;\r\n		this.Name     = $.Routines.GetNameFromID(iId);		\r\n		this.Type     = $.ObjectType.Namespace;\r\n		this.Items    = iII || [];\r\n\r\n		this.Parent   = iId.match($.Config.ParentRgx)[1] || undefined; //~~ Initially string, and then Node;\r\n		this.Children = [];\r\n		\r\n		Object.defineProperty(this,\"Value\", {get : function(){if(this.Items.length != 1) console.error(\"Attempting to access \" + this.Items.length + \" items with single item value request\"); return this.Items[0].Value;}});\r\n	 };\r\n	$.NodeItem                   = function(iId, iValue, iPack, iIsInstMem)\r\n	 {\r\n		this.ID           = iId;\r\n		this.Name         = $.Routines.GetNameFromID(iId)\r\n		this.Value        = iValue;\r\n		this.Pack         = iPack;\r\n		this.IsInstMember = iIsInstMem;\r\n		this.Node         = undefined;\r\n	 };\r\n\r\n	$.Routines = {};\r\n	$.Routines.GetNameFromID     = function(iId, oName)\r\n	 {\r\n		return iId.match($.Config.PathRgx)[1];\r\n	 };\r\n	$.Routines.LinkNodes         = function(iParentN, iChildN)\r\n	 {\r\n		iParentN.Children.push(iChildN);\r\n		iChildN.Parent = iParentN;\r\n\r\n		if(iParentN.Type == $.ObjectType.Class && iChildN.Type == $.ObjectType.Constructor)\r\n		{\r\n			iParentN.Constructor = iChildN;\r\n		}\r\n	 };\r\n	$.Routines.FlattenItems      = function(iBranchO, iCurrP, iPack, iIsInstMem, oII)\r\n	 {\r\n		var _IsInstMem = iIsInstMem;\r\n		{\r\n			var _IsInstPathM    = /\\.instance$/.test(iCurrP);\r\n			var _IsStatPathM    = /\\.static$/.test(iCurrP);\r\n			var _IsInstRoot     = iBranchO.hasOwnProperty(\"constructor\") || iBranchO.hasOwnProperty(\"static\");\r\n			var _IsStatRoot     = iBranchO.hasOwnProperty(\"initializer\") || iBranchO.hasOwnProperty(\"instance\");\r\n			var _IsClassRoot    = _IsInstRoot || _IsStatRoot;\r\n			var _IsDerivedClass = iBranchO.hasOwnProperty(\"inherits\");\r\n\r\n			var _HasFields      = false;\r\n			{\r\n				for(var cItemN in Object.getProperties(iBranchO))\r\n				{\r\n					var cItemDesc = Object.getOwnPropertyDescriptor(iBranchO, cItemN);\r\n					var cItemV    = cItemDesc.value;\r\n\r\n					if(typeof(cItemV) == \"function\" && $.Config.InlayRgx.test(cItemV.name) && cItemV.name != \"_jso\")\r\n					{\r\n						_HasFields = true;\r\n						break;\r\n					}\r\n				}\r\n			}\r\n			if(_IsInstRoot && _IsStatRoot)\r\n			{\r\n				throw \"WTF\";\r\n				//console.info(\"ND: _IsInstRoot && _IsStatRoot\");\r\n			}\r\n			if(!_IsStatRoot && (_IsInstPathM || _IsInstRoot || _IsDerivedClass || _HasFields)) _IsInstMem = true;\r\n		}\r\n\r\n		oII = [];\r\n		{\r\n			for(var cItemN in Object.getProperties(iBranchO))\r\n			{\r\n				var cIsInstMem = _IsInstMem;\r\n\r\n				if(cItemN.match(/^(uses|inherits)$/))             continue;\r\n				if(cItemN.match(/^(init|main)$/) && iCurrP == \"\") continue; //~~ Root 'init' (and 'main'?) can be duplicated;\r\n				if(cItemN == \"once\")                              continue;\r\n\r\n				var cDeclaM = cItemN.replace(/[\\/\\\\]/g,\".\").match($.Config.DeclaRgx);\r\n				{\r\n					if(!cDeclaM)\r\n					{\r\n						/*\r\n							decl       :: ident [dot ident] [':' ident [dot ident]]\r\n							dot        :: '.' | '/'\r\n							ident      :: ('_' | letter) ('_' | letter | digit)*\r\n							digit      :: '0'...'9'\r\n							letter     :: 'A'...'Z' | 'a'...'z'\r\n						*/\r\n\r\n						!$.IsTransformedState && $.AddMessage($.MessageType.FatalError, \"DODOCODE\", \"Invalid member declaration string: \\\"'\" + cItemN + \"'\\\"\", undefined, iPack.File.Url);\r\n						\r\n						continue;\r\n					}\r\n				}\r\n				\r\n				var cItemSubP  = cDeclaM[1].replace(/\\s*/g,\"\");\r\n				var cItemId    = (iCurrP != \"\" ? iCurrP + \".\" : \"\") + cItemSubP;\r\n				{\r\n					var cInstaM = cItemId.match(/(.+?\\.instance\\.)(.+?)$/);\r\n					var cStatiM = cItemId.match(/(.+?)\\.static\\.(.+?)$/);\r\n					\r\n					if(cInstaM){cIsInstMem = true;  cItemId = cItemId.replace(/\\.instance\\./g,\".\");}\r\n					if(cStatiM){cIsInstMem = false; cItemId = cItemId.replace(/\\.static\\./g,\".\");}\r\n				}\r\n				\r\n				var cItemV, cPropD = Object.getOwnPropertyDescriptor(iBranchO, cItemN);\r\n				{\r\n					if(cPropD.value != undefined)\r\n					{\r\n						cItemV = iBranchO[cItemN];\r\n\r\n						\r\n						if(typeof(cItemV) == \"object\" && cItemV != null)\r\n						{\r\n							Checks:\r\n							{\r\n								if(cDeclaM[3] != undefined) //~~ Class declaration;\r\n								{\r\n									if(cItemV.inherits == undefined)\r\n									{\r\n										cItemV.inherits = cDeclaM[3];\r\n									}\r\n									else $.IsTransformedState && $.AddMessage($.MessageType.Error, \"CLSINHER\", \"Multiple inheritance values\", cItemId, iPack.File.Url, []);\r\n								}\r\n							}\r\n							\r\n							if(typeof(cItemV.get) == \"function\" || typeof(cItemV.set) == \"function\")\r\n							{\r\n								//~~ Property that defined in preffered way;\r\n							}\r\n							else if(typeof(cItemV[\"init\"]) == \"function\")\r\n							{\r\n								//~~ Single member initializer;\r\n							}\r\n							else\r\n							{\r\n								$.CurrentItem = cItemN;\r\n								var cItemSubII = $.Routines.FlattenItems(cItemV, cItemId, iPack, cIsInstMem);\r\n								oII = oII.concat(cItemSubII);\r\n							}\r\n						}\r\n						else if(typeof(cItemV) == \"function\")\r\n						{\r\n							if(cItemV.name == \"_jso\")\r\n							{\r\n								//~~cItemV = cItemV();\r\n							}\r\n						}\r\n					}\r\n					else\r\n					{\r\n						//debugger;\r\n						//cItemV = cPropD;\r\n\r\n						cItemV = undefined;\r\n					}\r\n				}\r\n				if(!cItemN.match(/^(instance|static)$/))\r\n				{\r\n					oII.push(new $.NodeItem(cItemId, cItemV, iPack, cIsInstMem));\r\n				}\r\n			}\r\n		}\r\n		return oII;\r\n	 },\r\n	$.Routines.Eval              = function(iSrcS, iUrl, oIsOk)\r\n	 {\r\n		$.Files[iUrl].Packs = [];\r\n		\r\n		var _StuffF;\r\n		{\r\n			if(!$.IsTransformedState)\r\n			{\r\n				_StuffF        = function(iPackO){$.AddPack(iUrl, iPackO, undefined)};\r\n				_StuffF.import = $.import;\r\n				\r\n				try\r\n				{\r\n					$.CurrentFile = $.Files[iUrl];\r\n					Function(\"stuff\", iSrcS).call(null, _StuffF);\r\n				}\r\n				catch(_Exc)\r\n				{\r\n					if(1) $.AddMessage($.MessageType.FatalError, \"JSERRORS\", _Exc.message, $.CurrentItem, iUrl);\r\n					return false;\r\n				}\r\n			}\r\n			else\r\n			{\r\n				_StuffF        = Function(\"iTuple\", \"$.AddPack(iTuple[0], iTuple[1], iTuple[2]);\");\r\n				_StuffF.import = Function(\"/*-- empty --*/\");\r\n				\r\n				Function(\"stuff\", iSrcS).call(null, _StuffF);\r\n			}\r\n		}\r\n		return true;\r\n	 },\r\n	$.Routines.GetUsedNodes      = function(iUsesS, oCloDict)\r\n	 {\r\n		/**\r\n			uses\r\n			[\r\n				\"System.Math\",                            //Include all members\r\n				\"System.Math: Sin, Cos\",                  //Include only specified\r\n				\"System.Math: *, -Sin\",                   //Include all but specified\r\n				\r\n				\"System.Drawing\",\r\n				\"System.Drawing: Point, Size\",            //Point, Size only\r\n				\"System.Drawing (*2D)\",                   //Point2D, Size2D\r\n				\r\n				\"System.Windows.Forms (WinForms)\",        //WinForms.Frame, WinForms.Form\r\n				\"System.Windows.Forms (WF*)\",             //WFFrame, WFForm, WFButton\r\n			]\r\n		*/\r\n		iUsesS = iUsesS.trim();\r\n		\r\n		var _NsId, _ExtraAA, _PickedNN, _AllButNN, _AliasN, _PrefixS = \"\", _SuffixS = \"\";\r\n		{\r\n			var _UsingM = iUsesS.match(/^([\\w\\d\\.\\s]+)(.*)$/);\r\n			{\r\n				_NsId    = _UsingM[1].trim();\r\n				_ExtraAA = _UsingM[2].trim();\r\n				\r\n				if(_ExtraAA.length != 0)\r\n				{\r\n					var _PickedMM = _ExtraAA.match(/^:\\s*(?!\\s*\\*)([^\\(]+)/);  //~~ \": Sin, Cos\";\r\n					var _AllButMM = _ExtraAA.match(/^:\\s*\\*\\s*,\\s*([^\\(]+)/);  //~~ \": *, -Sin, -Cos\";\r\n					var _AliasM   = _ExtraAA.match(/\\(\\s*(\\w+)\\s*\\)$/);        //~~ \"(ALIAS)\";\r\n					var _PrefixM  = _ExtraAA.match(/\\(\\s*(\\w+)\\*\\s*\\)$/);      //~~ \"(PFX*)\";\r\n					var _SuffixM  = _ExtraAA.match(/\\(\\s*\\*(\\w+)\\s*\\)$/);      //~~ \"(*SFX)\";\r\n					\r\n					if(_PickedMM != null) _PickedNN = _PickedMM [1].split(\",\").map(function(iS){return iS.trim();});\r\n					if(_AllButMM != null) _AllButNN = _AllButMM [1].split(\",\").map(function(iS){return iS.trim().replace(/^-/,\"\");});\r\n					if(_AliasM   != null) _AliasN   = _AliasM   [1];\r\n					if(_PrefixM  != null) _PrefixS  = _PrefixM  [1];\r\n					if(_SuffixM  != null) _SuffixS  = _SuffixM  [1];\r\n				}\r\n			}\r\n		}\r\n\r\n		oCloDict = new function ClosureDictionary(){};\r\n		{\r\n			if(_AliasN != undefined)\r\n			{\r\n				var cCloNodeI = {};\r\n				{\r\n					cCloNodeI.ID     = _NsId;\r\n					cCloNodeI.Alias  = _AliasN;\r\n				}\r\n				oCloDict[cCloNodeI.Alias] = cCloNodeI;\r\n			}\r\n			else\r\n			{\r\n				var _NsRgx    = new RegExp(\"^\" + _NsId.replace(/\\./g,\"\\\\.\") + \"\\\\.([A-Z][\\\\w\\\\d]*)$\");\r\n				\r\n				if(window[_NsId])\r\n				{\r\n					//~~ Using internal 'window' and already imported third-party objects;\r\n					for(var cPropN in Object.getProperties(window[_NsId]))\r\n					{\r\n						if(_PickedNN && _PickedNN.indexOf(cPropN) == -1) continue;\r\n						if(_AllButNN && _AllButNN.indexOf(cPropN) != -1) continue;\r\n						\r\n						var cCloI =  {ID : _NsId + \".\" + cPropN, Alias : _PrefixS + cPropN + _SuffixS, IsGenerated : false};\r\n						oCloDict[cCloI.Alias] = cCloI;\r\n					}\r\n				}\r\n				\r\n				//~~ Additional objects as nodes;\r\n				for(var cNodeId in Object.getProperties($.Nodes))\r\n				{\r\n					var cNodeNsM    = cNodeId.match(_NsRgx); if(!cNodeNsM)  continue;\r\n					var cNodeAliasN = cNodeNsM[1];\r\n					\r\n					if(_PickedNN && _PickedNN.indexOf(cNodeAliasN) == -1) continue;\r\n					if(_AllButNN && _AllButNN.indexOf(cNodeAliasN) != -1) continue;\r\n					if($.Nodes[cNodeId].Type == $.ObjectType.Field)       continue;\r\n					\r\n\r\n					if(oCloDict[cNodeId])throw \"WTF\";\r\n					\r\n					var cCloNodeI = {ID : cNodeId, Alias : _PrefixS + cNodeAliasN + _SuffixS, IsGenerated : true};\r\n					oCloDict[cCloNodeI.Alias] = cCloNodeI;\r\n				}\r\n			}\r\n		}\r\n		return oCloDict;\r\n	 },\r\n	$.Routines.GetNodeIdByAlias  = function(iAlias, iPack, oFoundId)\r\n	 {\r\n		var _UsedNsSS = Object.getOwnPropertyNames(iPack.Structure).concat(iPack.Uses || []);\r\n\r\n		for(var cUsedS,Si = 0; cUsedS = _UsedNsSS[Si], Si < _UsedNsSS.length; Si++)\r\n		{\r\n			var cUsedAA = $.Routines.GetUsedNodes(cUsedS);\r\n			\r\n			for(var cAlias in cUsedAA)\r\n			{\r\n				if(cAlias == iAlias)\r\n				{\r\n					if(oFoundId == undefined) oFoundId = cUsedAA[cAlias].ID;\r\n					else $.AddMessage($.MessageType.FatalError, \"CLOSURES\", \"Alias collision detected\", iAlias, iPack.File.Url);\r\n				}\r\n			}\r\n		}\r\n		return oFoundId;\r\n	 };\r\n	$.Routines.GetPrototypeInfo  = function(iNode, oProtoI)\r\n	 {\r\n		oProtoI = {Value : {}, IsModified : false, IsPrimary : false};\r\n		{\r\n			if(window[iNode.ID] != undefined)\r\n			{\r\n				oProtoI.Value      = Object.getDescriptors(window[iNode.ID].prototype, true);\r\n				oProtoI.IsModified = true;\r\n				oProtoI.IsPrimary  = true;\r\n			}\r\n			else\r\n			{\r\n				if(iNode.BaseClass)\r\n				{\r\n					var _BaseProtoI = $.Routines.GetPrototypeInfo(iNode.BaseClass);\r\n\r\n					if(_BaseProtoI.IsModified)\r\n					{\r\n						oProtoI.Value = _BaseProtoI.Value;\r\n						oProtoI.IsModified = true;\r\n					}\r\n				}\r\n				\r\n				for(var cI,Ii = 0; cI = iNode.Items[Ii]; Ii++)\r\n				{\r\n					var cInstO = Object.getDescriptors(cI.Value[\"instance\"] || cI.Value);\r\n					{\r\n						for(var cDecla in cInstO)\r\n						{\r\n							if(cDecla == \"inherits\") continue;\r\n							\r\n							var cMemN = cDecla.match($.Config.DeclaRgx)[1];\r\n							var cMemD = $.Nodes[iNode.ID + \".~\" + cMemN];\r\n							{\r\n								if(!cMemD)                                  continue;\r\n								if( cMemD.Type == $.ObjectType.Field)       continue;\r\n								if( cMemD.Type == $.ObjectType.Constructor) continue;\r\n								if( cMemD.Items.length == 0)                throw \"WTF\";\r\n								if(!cMemD.IsInstMember)                     continue;\r\n							}\r\n							\r\n							if(!cMemN.match(/^inherits|static$/))\r\n							{\r\n								var cDesc = cInstO[cMemN];\r\n								{\r\n									oProtoI.Value[cMemN] = cDesc.get || cDesc.set ? cDesc : (cDesc.value && (cDesc.value.get || cDesc.value.set)) ? cDesc.value : cDesc;\r\n								}\r\n								oProtoI.IsModified = true;\r\n							}\r\n						}\r\n					}\r\n				}\r\n			}\r\n		}\r\n		return oProtoI;\r\n	 };\r\n	$.Routines.CreateDescriptor  = function(iNode, oDesc)\r\n	 {\r\n		switch(iNode.Type)\r\n		{\r\n			case $.ObjectType.Class        : oDesc = {value : iNode.Constructor.Value};              break;\r\n			case $.ObjectType.Initializer  : \r\n			case $.ObjectType.Function     : \r\n			case $.ObjectType.Method       : \r\n			case $.ObjectType.Array        : \r\n			case $.ObjectType.Undefined    : //~~;\r\n			case $.ObjectType.Value        : oDesc = {value : iNode.Value};                          break;\r\n			case $.ObjectType.JsObject     : oDesc = {value : iNode.Value.call()};                   break;\r\n			case $.ObjectType.Property     : oDesc = iNode.Value;                                    break;\r\n			case $.ObjectType.Oncer        : oDesc = {get : iNode.Value, configurable : true};       break;\r\n\r\n			//case $.ObjectType.Undefined    : oDesc = {value : undefined};                            break;\r\n			\r\n			default                        : oDesc = {value : new function Namespace(){}, writable : true};\r\n		}\r\n		return oDesc;\r\n	 };\r\n	\r\n\r\n	$.AddPack                    = function(iUrl, iTreeO, iCloseF)\r\n	 {\r\n		var _Pack = new $.Pack(iUrl, iTreeO, iCloseF);\r\n		{\r\n			if($.IsTransformedState)\r\n			{\r\n				if(_Pack.Main) $.EntryPoints.push(_Pack);\r\n			}\r\n		}\r\n		this.Files[iUrl].Packs.push(_Pack);\r\n	 };\r\n	$.AddFile                    = function(iFile, oIsOk)\r\n	 {\r\n		if($.Files[iFile.Url]) throw \"WTF\";\r\n		\r\n		$.CurrentFile = $.Files[iFile.Url] = iFile;\r\n		\r\n		return $.Routines.Eval(iFile.Source, iFile.Url);\r\n	 };\r\n	$.AddMessage                 = function(iType, iLogN, iText, iNodeII, iFileUU, iLineNN, iDoUseCns)\r\n	 {\r\n		if(iType     == undefined) throw \"WTF\";\r\n		if(iDoUseCns == undefined) iDoUseCns = true;\r\n\r\n		if(iNodeII == undefined) iNodeII = [];  if(!(iNodeII instanceof Array)) iNodeII = [iNodeII];\r\n		if(iFileUU == undefined) iFileUU = [];  if(!(iFileUU instanceof Array)) iFileUU = [iFileUU];\r\n		if(iLineNN == undefined) iLineNN = [];  if(!(iLineNN instanceof Array)) iLineNN = [iLineNN];\r\n\r\n		var _MsgS = \"JSTUFF(\" + iLogN + \"): \" + (iNodeII.length != 0 ? \"'\" + iNodeII.join(\", \") + \"' - \" : \"\") + iText;\r\n		{\r\n			if(iDoUseCns) switch(iType)\r\n			{\r\n				case $.MessageType.Notification :\r\n				case $.MessageType.Tip          : console.info(_MsgS); break;\r\n				case $.MessageType.Warning      : console.warn(_MsgS); break;\r\n				\r\n				case $.MessageType.FatalError   : $.IsFailedState = true;\r\n				case $.MessageType.Error        :\r\n				{\r\n					if(iLogN == \"JSERRORS\" || iLogN == \"DODOCODE\")\r\n					{\r\n						_MsgS = \"JSTUFF(\" + iLogN + \"): \" + iText + (iFileUU.length == 1 && iLineNN.length == 1 ? \" [at \" + iFileUU[0] + \":\" + iLineNN[0] + \"]\" : \"\");\r\n					}\r\n					console.error(_MsgS);\r\n					\r\n					break;\r\n				}\r\n				default : throw \"WTF\";\r\n			}\r\n		}\r\n		$.Debug && $.Debug.AddLogRecord(iType, iLogN, iText, iNodeII, iFileUU, iLineNN);\r\n	 },\r\n	$.TransformFiles             = function()\r\n	 {\r\n		$.IsTransformedState = true;\r\n		\r\n		for(var cUrl in Object.getProperties(this.Files))\r\n		{\r\n			var cFile = $.CurrentFile = this.Files[cUrl]; if(cFile.Packs.length == 0) continue;\r\n			var cFuncS = cFile.Source;\r\n			{\r\n				var cMuLineComMM = cFuncS.match(/\\/\\*[\\S\\s]*?\\*\\//g);\r\n				{\r\n					if(cMuLineComMM) for(var cM,Mi = 0; cM = cMuLineComMM[Mi], Mi < cMuLineComMM.length; Mi++)\r\n					{\r\n						cFuncS = cFuncS.replace(cM, cM.replace(/stuff[\\S\\s]*?\\(\\{/g,\"x-$&\"));\r\n					}\r\n				}\r\n				cFuncS = cFuncS.replace(/(\\/\\/.*?)(?!x-)(stuff)(.*?)/g, \"$1x-$2$3\");\r\n\r\n				var cPackMM = [];\r\n				{\r\n					var _BegPackRgx   = /(\\w+\\s*:\\s*)?(stuff[\\s\\S]*?\\n ?\\(\\{)/;\r\n					var _EndPackRgx   = /\\n ?\\}\\);?/;\r\n					var _WholePackRgx = new RegExp(_BegPackRgx.source + /([\\S\\s]*?)/.source + _EndPackRgx.source, \"g\");\r\n\r\n					for(var cPackM, cPackI = 0; cPackM = _WholePackRgx.exec(cFuncS); cPackI++)\r\n					{\r\n						cPackMM.push\r\n						({\r\n							Index    : cPackI,\r\n							Position : cPackM.index,\r\n							Source   : cPackM[0].toString(),\r\n							Result   : undefined\r\n						});\r\n					}\r\n					\r\n					if(cPackMM.length == 0) throw \"ERR: Packs found in file but not in source (Regex?)\";\r\n					if(cPackMM.length != cFile.Packs.length)\r\n					{\r\n						if($.Debug && $.Debug.Logs[\"JSERRORS\"].Records.length != 0)\r\n						{\r\n							continue; //~~ Syntax error may cause this behavior;\r\n						}\r\n						else throw \"ERR: Pack count mismatch in source and file (Regex?)\";\r\n					}\r\n					\r\n					for(var cPackM,Mi = 0; cPackM = cPackMM[Mi], Mi < cPackMM.length; Mi++)\r\n					{\r\n						var cPack      = cFile.Packs[Mi];\r\n						var cPackCC    = [{ID : \"window\", Alias : \"$\"}]; for(var cAlias in Object.getProperties(cPack.Closures)) cPackCC.push(cPack.Closures[cAlias]);\r\n						\r\n						var cOpdS = cPackM.Source;\r\n						{\r\n							cOpdS = cOpdS.replace(/:\\s*\\(\\s*'([A-Z][\\w\\d]*)\\s*'\\s*,\\s*(.*?)\\)/g,\": {get once(){return new $1($2)}}\"); //~~ Grey : ('Color', 127, 127, 127);\r\n							cOpdS = cOpdS.replace($.Config.AssignRgx, \"$1 = $1 === self ? $2 : $1 || $4;\");                           //~~ oVal = oVal === self ? this : oVal || new Value;\r\n\r\n							cOpdS = cOpdS.replace($.Config.ThisArgRgx1, \"this.$1 = i$1 !== undefined ? i$1 : $2;\");\r\n							cOpdS = cOpdS.replace($.Config.ThisArgRgx2, \"this.$1 = i$1;\");\r\n							cOpdS = cOpdS.replace($.Config.ThisArgRgx3, \"this.$2 = $1 !== undefined ? $1 : $3;\");\r\n							cOpdS = cOpdS.replace($.Config.ThisArgRgx4, \"this.$2 = $1;\");\r\n\r\n							cOpdS = cOpdS.replace($.Config.ErrorArgRgx1, \"$1 new function(){throw $3};\");\r\n							cOpdS = cOpdS.replace($.Config.ErrorArgRgx2, \"$1 new function(){throw \\\"Argument not specified: '$2'\\\"};\");\r\n							\r\n							/**\r\n								//~~ 'overriden' sugar;\r\n\r\n								this.overriden()                     ->  this.overriden.call  (this);\r\n								this.overriden(iX,iY)                ->  this.overriden.call  (this,iX,iY);\r\n								this.overriden(arguments)            ->  this.overriden.apply (this,arguments);\r\n								this.overriden.Method1(iX,iY)        ->  this.overriden.prototype.Method.call   (this,iX,iY);\r\n								\r\n\r\n								this.overriden()                     ->  Classes[565].call  (this);\r\n								this.overriden(iX,iY)                ->  Classes[565].call  (this,iX,iY);\r\n								this.overriden(arguments)            ->  Classes[565].apply (this,arguments);\r\n								\r\n								this.overriden.Method1(iX,iY)        ->  Classes[565] .prototype.Method.call (this,iX,iY);\r\n								(???)this.overriden[1].Method(iX,iY) ->  Classes[1238].prototype.Method.call (this,arguments);\r\n							*/\r\n\r\n							cOpdS = cOpdS.replace(/[ \\t]*\\/\\/[ \\t]*this\\s*\\.\\s*overriden\\s*[^;]*;/g, \"\");\r\n							{\r\n								if(/\\bthis\\s*\\.\\s*overriden\\b/.test(cOpdS))\r\n								{\r\n									var _Len = cOpdS.length;\r\n									{\r\n										cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden\\s*(?!\\.prototype)\\.\\s*([\\.\\w\\d]+?)\\(\\s*arguments\\s*\\)/g,  \"this.overriden.prototype.$1.apply(this,arguments)\");\r\n										cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden\\s*\\.\\s*([\\.\\w\\d]+?)\\(\\s*\\)/g,                             \"this.overriden.prototype.$1.call(this)\");\r\n										cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden\\s*(?!\\.prototype)\\.\\s*([\\.\\w\\d]+?)\\(/g,                   \"this.overriden.prototype.$1.call(this,\");\r\n										\r\n										cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden\\s*\\(\\s*arguments\\s*\\)/g,                                  \"this.overriden.apply(this,arguments)\");\r\n										cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden\\s*\\(\\s*\\)/g,                                              \"this.overriden.call(this)\");\r\n										cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden[ \\t]*\\(/g,                                                \"this.overriden.call(this,\");\r\n										cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden[ \\t\\r]*\\n([ \\t]*)\\(/g,                                    \"this.overriden.call\\r\\n$1(this,\");\r\n									}\r\n									if(_Len != cOpdS.length)\r\n									{\r\n										for(var cLen, pLen; cLen = cOpdS.length, cLen != pLen; pLen = cLen)\r\n										{\r\n											cOpdS = cOpdS.replace(/this\\s*\\.\\s*overriden/,\"$Classes[\" + (++$.LastClassIndex) + \"]\");\r\n										}\r\n									}\r\n								}\r\n							}\r\n							cOpdS = cOpdS.replace(/([_a-z]\\w*)\\$\\D\\w+/g,\"$1\"); //~~ function(i1$num, i2$num, o1$boo);\r\n\r\n							//~~ Pack source wrapping;\r\n							cOpdS = cOpdS.replace(_BegPackRgx, \"$1stuff\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t((function(){var $Closures, \" + cPackCC.map(function(iV){return iV.Alias}).join(\",\") + \"; var $ = \\r\\n{\");\r\n							cOpdS = cOpdS.replace(_EndPackRgx, \"\\r\\n};\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn [\\\"\" + cFile.Url + \"\\\", $, function(iClosures){$Closures = iClosures; \" + cPackCC.map(function(iV){return iV.Alias + \" = \" + iV.ID}).join(\"; \") + \";}]})());\");\r\n						}\r\n						cPackMM[Mi].Result = cOpdS;\r\n					}\r\n				}\r\n				\r\n				for(var pSrcLen = cFuncS.length, cPosDrift = 0, cPackM,Mi = 0; cPackM = cPackMM[Mi], Mi < cPackMM.length; Mi++, pSrcLen = cFuncS.length)\r\n				{\r\n					if(cPackM.Result == undefined) continue;\r\n					\r\n					var _BefS = cFuncS.substring(0, cPackM.Position + cPosDrift);\r\n					var _AftS = cFuncS.substring(cPackM.Position + cPosDrift + cPackM.Source.length);\r\n					\r\n					cFuncS = _BefS + cPackM.Result + _AftS;\r\n					\r\n					cPosDrift += cFuncS.length - pSrcLen;\r\n				}\r\n				\r\n				cFuncS += \"//# sourceURL=jstuff://\" + cUrl.match(/(.*?)\\.\\w+$/)[1] + \"\\r\\n\";\r\n				//cFuncS += \"//@ sourceURL=\" + cUrl.match(/(.*?)\\.\\w+$/)[1];// + \"\\r\\n\";\r\n			}\r\n			cFile.Compiled = cFuncS;\r\n			\r\n			$.Routines.Eval(\"\" + cFuncS.replace(/(\"use strict\";)\\s*/,\"$1 \") + \"\", cUrl);\r\n		}\r\n		$.CurrentPack = undefined;\r\n	 };\r\n	$.CreateFiles                = function()\r\n	 {\r\n		for(var cFileId in Object.getProperties(this.SourceList))\r\n		{\r\n			var cFileData = this.SourceList[cFileId];\r\n\r\n			if(cFileData && cFileData.length > 0)\r\n			{\r\n				var _IsSuccess = $.AddFile(new $.File(cFileId, cFileData)); if(!_IsSuccess)\r\n				{\r\n					//~~$.load(cFileId.match(/^.*?\\/(.*)$/)[1]);\r\n					$.load(cFileId);\r\n				}\r\n			}\r\n		}\r\n	 },\r\n	$.CreateNodes                = function(iDoLogEE, _NN)\r\n	 {\r\n		if(!iDoLogEE) iDoLogEE = $.IsTransformedState;\r\n	\r\n		var _II = [];\r\n		{\r\n			for(var _UrlA = Object.getOwnPropertyNames(this.Files), cFile,Ui = 0; cFile = this.Files[_UrlA[Ui]]; Ui++)\r\n			{\r\n				for(var cPack,Pi = 0; cPack = cFile.Packs[Pi]; Pi++)\r\n				{\r\n					for(var cItem,Ii = 0; cItem = cPack.Items[Ii]; Ii++)\r\n					{\r\n						if(cItem.IsInstMember)\r\n						{\r\n							cItem.ID = cItem.ID.replace(this.Config.NameOnlyRgx, \"~$&\")\r\n						}\r\n						_II.push(cItem);\r\n					}\r\n				}\r\n			}\r\n			\r\n			_II.sort\r\n			(\r\n				function(ixI,iyI)\r\n				{\r\n					if(ixI.ID == iyI.ID)\r\n					{\r\n						var ixIsO = typeof(ixI.Value) == \"object\";\r\n						var iyIsO = typeof(iyI.Value) == \"object\";\r\n						{\r\n							if( ixIsO && !iyIsO) return +1;\r\n							if(!ixIsO &&  iyIsO) return -1;\r\n							\r\n							if( ixIsO &&  iyIsO) return 0;\r\n							if(!ixIsO && !iyIsO) iDoLogEE && this.AddMessage($.MessageType.FatalError, \"ITEMCONF\", \"The node has multiple non-object items\", ixI.ID, [ixI.Pack.File.Url, iyI.Pack.File.Url],[]);\r\n						}\r\n						return 0;\r\n					}\r\n					else return ixI.ID > iyI.ID ? +1 : -1;\r\n				}\r\n				.bind(this)\r\n			);\r\n		}\r\n		\r\n		_NN = {};\r\n		{\r\n			\r\n			var fSetNodeType = function(iN,iT)\r\n			{\r\n				if(arguments.length == 3) throw \"WTF\";\r\n\r\n				if(iN.Type == $.ObjectType.Namespace || iT == $.ObjectType.Namespace)\r\n				{\r\n					if(iT != $.ObjectType.Namespace)\r\n					{\r\n						iN.Type = iT;\r\n					}\r\n				}\r\n				else\r\n				{\r\n					if(iN.Type != iT)\r\n					{\r\n						iNoLogEE && $.AddMessage\r\n						(\r\n							$.MessageType.FatalError, \"TYPECONF\", \"Inconsistent object type\", iN.ID,\r\n							iN.Items.map(function(iI){return iI.Pack.File.Url}), []\r\n						);\r\n					}\r\n				}\r\n			}\r\n\r\n			for(var cI,Ii = 0; cI = _II[Ii], Ii < _II.length; Ii++)\r\n			{\r\n				var cN = _NN[cI.ID] = _NN[cI.ID] || new $.Node(cI.ID);\r\n				\r\n				cN.Items.push(cI);\r\n				cI.Node = cN;\r\n\r\n				cN.IsInstMember |= cI.IsInstMember;\r\n			}\r\n			\r\n			\r\n			for(var cNodeId in Object.getProperties(_NN))\r\n			{\r\n				var cN = _NN[cNodeId]; for(var cI,Ii = 0; cI = cN.Items[Ii], Ii < cN.Items.length; Ii++)\r\n				{\r\n					if   (cI.Value == undefined) fSetNodeType(cN, this.ObjectType.Undefined);\r\n					else\r\n					{\r\n						var cValType    = typeof cI.Value;\r\n						var cValIsNull  = cI.Value == null;\r\n						var cValIsUndef = cValType == \"undefined\";\r\n						var cValIsObj   = cValType == \"object\" && !cValIsNull;\r\n						var cValIsFunc  = cValType == \"function\";\r\n						var cValIsNum   = cValType == \"number\";\r\n						var cValIsStr   = cValType == \"string\";\r\n						var cValIsArray = cI.Value instanceof Array;\r\n						var cValIsValue = cValIsArray || $.Config.ValTypeRgx.test(cValType);\r\n						\r\n						var cValIsProp  = cValIsObj   && (typeof(cI.Value.get) == \"function\" || typeof(cI.Value.set) == \"function\");\r\n						var cValIsOncer = cValIsObj   && cI.Value.hasOwnProperty(\"once\");\r\n						var cValIsInlay = cValIsFunc  && $.Config.InlayRgx.test(cI.Value.name);\r\n						var cValIsJsObj = cValIsInlay && cI.Value.name == \"_jso\";\r\n						var cValIsClass = cValIsObj   && (cI.Value.hasOwnProperty(\"instance\") || cI.Value.hasOwnProperty(\"inherits\") || cI.Value.hasOwnProperty(\"constructor\"));\r\n						\r\n						if (cValIsUndef) fSetNodeType(cN, this.ObjectType.Undefined);\r\n						else\r\n						{\r\n							if(cValIsValue)\r\n							{\r\n								fSetNodeType(cN, this.ObjectType.Value);\r\n							}\r\n							else if(cValIsObj)\r\n							{\r\n								if      (cI.Name == \"instance\") fSetNodeType(cN, this.ObjectType.Instance);\r\n								else if (cI.Name == \"static\")   fSetNodeType(cN, this.ObjectType.Static);\r\n								else if (cValIsClass)           fSetNodeType(cN, this.ObjectType.Class);\r\n								else if (cValIsProp)            fSetNodeType(cN, this.ObjectType.Property);\r\n								else if (cValIsOncer)\r\n								{\r\n									var _OncerD = Object.getOwnPropertyDescriptor(cI.Value, \"once\");\r\n									\r\n									if(typeof(_OncerD[\"get\"]) == \"function\")\r\n									{\r\n										cI.Value = Function(\"iGetterF\",\"return function(){Object.defineProperty(\" + cN.Parent + \", \\\"\" + cN.Name + \"\\\", {value : iGetterF(), writable : true}); return \" + cN.ID + \";}\")(_OncerD[\"get\"]);\r\n\r\n										fSetNodeType(cN, this.ObjectType.Oncer);\r\n									}\r\n									else throw \"WTF\";\r\n								}\r\n								else if(cValIsArray)   fSetNodeType(cN, this.ObjectType.Array);\r\n								else\r\n								{\r\n									if(cI.Name == \"LastComputedEntry\") debugger;\r\n									fSetNodeType(cN, this.ObjectType.Namespace);\r\n								}\r\n							}\r\n							else\r\n							{\r\n								if(cValIsFunc)\r\n								{\r\n									if(cValIsInlay)\r\n									{\r\n										if(cValIsJsObj) fSetNodeType(cN, this.ObjectType.JsObject);\r\n										else\r\n										{\r\n											fSetNodeType(cN, this.ObjectType.Field);\r\n											\r\n											if(cN.Name.indexOf(\"~\") == -1)\r\n											{\r\n												cN.Name         = cI.Name         = \"~\" + cI.Name;\r\n												cN.ID           = cI.ID           = cI.ID.match($.Config.ParentRgx)[1] + \".\" + cI.Name;\r\n												cN.IsInstMember = cI.IsInstMember = true;\r\n											}\r\n										};\r\n									}\r\n									else\r\n									{\r\n										if (cI.IsInstMember) fSetNodeType(cN, cI.Name == \"constructor\" ? this.ObjectType.Constructor : this.ObjectType.Method);\r\n										else                 fSetNodeType(cN, cI.Name == \"initializer\" ? this.ObjectType.Initializer : this.ObjectType.Function);\r\n									}\r\n								}\r\n								else throw \"WTF\";\r\n							}\r\n						}\r\n						if(cN.Type == undefined)\r\n						{\r\n							throw \"WTF\";\r\n						}\r\n					}\r\n				}\r\n			}\r\n			//~~ Filling missing chain links in 'Existing.Missing.Existing';\r\n			for(var cNodeId in Object.getProperties(_NN)) \r\n			{\r\n				for(var _IdLL = cNodeId.split('.'), cId = _IdLL[0], Li = 0; Li < _IdLL.length; cId = cId + \".\" + _IdLL[++Li])\r\n				{\r\n					if(!_NN[cId])\r\n					{\r\n						_NN[cId] = new $.Node(cId);\r\n					}\r\n				}\r\n			}\r\n			\r\n			//~~ Processing relations;\r\n			for(var cNodeId in Object.getProperties(_NN)) \r\n			{\r\n				var cN = _NN[cNodeId];\r\n				{\r\n					if(cN.Parent)\r\n					{\r\n						$.Routines.LinkNodes(_NN[cN.Parent], cN);\r\n						\r\n						if(cN.Type == $.ObjectType.Field && cN.Parent.Type == $.ObjectType.Namespace)\r\n						{\r\n							cN.Parent.Type = $.ObjectType.Class;\r\n						}\r\n					}\r\n				}\r\n			}\r\n		}\r\n		this.Nodes = _NN;\r\n\r\n		if(this.Debug)\r\n		{\r\n			this.Debug.Items = _II;\r\n			this.Debug.Nodes = Object.getOwnPropertyNames(_NN).map(function(iNodeN){return _NN[iNodeN]});\r\n		}\r\n	 };\r\n	$.CreateClosureTables        = function()\r\n	 {\r\n		for(var cUrl in Object.getProperties(this.Files))\r\n		{\r\n			var cFile = this.Files[cUrl]; for(var cPack,Pi = 0; cPack = cFile.Packs[Pi]; Pi++)\r\n			{\r\n				cPack.Closures = {};\r\n				\r\n				var cPackUU = [];\r\n				{\r\n					for(var cNsId in Object.getProperties(cPack.Structure)) cPackUU.push(cNsId);\r\n					\r\n					if(cPack.Uses) cPackUU = cPackUU.concat(cPack.Uses);\r\n				}\r\n				\r\n				for(var cUsesS,Ui = 0; cUsesS = cPackUU[Ui], Ui < cPackUU.length; Ui++)\r\n				{\r\n					var cUsedDict = $.Routines.GetUsedNodes(cUsesS);\r\n					\r\n					for(var cAliasN in Object.getProperties(cUsedDict))\r\n					{\r\n						var cUsedId  = cUsedDict[cAliasN].ID;\r\n						var cUsedNode = $.Nodes[cUsedId];\r\n						{\r\n							if(cUsedNode)\r\n							{\r\n								if(cUsedNode.Type == $.ObjectType.Oncer)\r\n								{\r\n									!this.IsTransformedState && this.AddMessage($.MessageType.FatalError, \"CLOSURES\",\"Closed oncer property\", cUsedId, cPack.File.Url);\r\n									continue;\r\n								}\r\n							}\r\n						}\r\n						//if(cAliasN == \"toSource\") debugger;\r\n\r\n						if(cPack.Closures[cAliasN] != undefined)\r\n						{\r\n							if(cPack.Closures[cAliasN].ID != cUsedId) !this.IsTransformedState && this.AddMessage\r\n							(\r\n								$.MessageType.FatalError, \"CLOSURES\",\r\n								\"Alias '\" + cAliasN + \"' is already in use\",\r\n								[cUsedId, cPack.Closures[cAliasN].ID],\r\n								cPack.File.Url\r\n							);\r\n							else continue;\r\n						}\r\n						else cPack.Closures[cAliasN] = cUsedDict[cAliasN];\r\n					}\r\n				}\r\n			}\r\n		}\r\n	 };\r\n	$.ProcessInheritance         = function()\r\n	 {\r\n		for(var cNodeId in Object.getProperties($.Nodes))\r\n		{\r\n			var cN = $.Nodes[cNodeId]; if(cN.Type != $.ObjectType.Class) continue;\r\n			\r\n			var _BaseClassId = undefined;\r\n			{\r\n				for(var cI,Ii = 0; cI = cN.Items[Ii]; Ii++)\r\n				{\r\n					var cBaseAlias = cI.Value[\"inherits\"], cBaseClassId = undefined;\r\n\r\n					if(cBaseAlias != undefined)\r\n					{\r\n						if($.Nodes.hasOwnProperty(cBaseAlias))\r\n						{\r\n							cBaseClassId = cBaseAlias;\r\n						}\r\n						else if(cBaseAlias.indexOf('.') != -1)\r\n						{\r\n							var _NsPart = $.Routines.GetNodeIdByAlias(cBaseAlias.match(/^([^\\.]+)/)[1], cI.Pack);\r\n							\r\n							if(_NsPart != undefined && $.Nodes.hasOwnProperty(_NsPart))\r\n							{\r\n								cBaseClassId = _NsPart + \".\" + cBaseAlias.match(/^\\w+\\.([\\w\\.]+)$/)[1];\r\n							}\r\n						}\r\n						else\r\n						{\r\n							cBaseClassId = $.Routines.GetNodeIdByAlias(cBaseAlias, cI.Pack);\r\n						}\r\n\r\n						if(cBaseClassId != undefined)\r\n						{\r\n							if     (_BaseClassId == undefined)    _BaseClassId = cBaseClassId;\r\n							else if(cBaseClassId != _BaseClassId) $.IsTransformedState && $.AddMessage($.MessageType.FatalError, \"CLSINHER\",\"Class derives from different base classes: '\" + _BaseClassId + \"', '\" + cBaseClassId +  \"'\", cN.ID, [cI.Pack.File.Url]);\r\n						}\r\n						else $.IsTransformedState && $.AddMessage($.MessageType.FatalError, \"CLSINHER\",\"Base class '\" + cBaseAlias + \"' not found\", cN.ID, [cI.Pack.File.Url]);\r\n					}\r\n				}\r\n			}\r\n			\r\n			if(_BaseClassId != undefined)\r\n			{\r\n				cN.BaseClass = $.Nodes[_BaseClassId];\r\n			}\r\n		}\r\n	 };\r\n	$.CreateConstructors         = function()\r\n	 {\r\n		for(var cNodeId in Object.getProperties($.Nodes)) \r\n		{\r\n			if($.Nodes[cNodeId].Type != $.ObjectType.Class) continue;\r\n\r\n			var cClassNode       = $.Nodes[cNodeId];\r\n			var cBaseClassN      = cClassNode.BaseClass;\r\n			var cIsDerived       = cBaseClassN != undefined;\r\n\r\n			var cCtorNodeId      = cClassNode.ID + \".~constructor\";\r\n			var cCtorNode        = $.Nodes[cCtorNodeId];\r\n			var cCtorExists      = cCtorNode != undefined;\r\n			var cCtorFunc        = cCtorExists ? cCtorNode.Value : null;\r\n			var cCtorName        = cCtorFunc != undefined ? cCtorFunc.name : \"\";\r\n			\r\n			var cCtorIsCustom    = cCtorName == \"custom\";\r\n			var cCtorIsAnnex     = cCtorName == \"annex\";\r\n			var cCtorIsAnonym    = cCtorName == \"\";\r\n			\r\n\r\n			var cFieldNN         = cClassNode.Children.filter(function(iNestedN){return iNestedN.Type == $.ObjectType.Field});\r\n			var cHasFields       = cFieldNN.Length != 0;\r\n\r\n			var cNeedsFieldsInit = (!cCtorExists && cHasFields) || cCtorIsAnnex;\r\n			var cNeedsBaseInvoc  = !cCtorIsCustom && cIsDerived;\r\n			var cCtorNeedsUpdate = !cCtorExists || cCtorIsAnonym || cNeedsFieldsInit || cNeedsBaseInvoc;\r\n			\r\n\r\n			if(cCtorNeedsUpdate)\r\n			{\r\n				var _CtorS = \"\";\r\n				{\r\n					if(!cCtorExists || !cCtorIsCustom)\r\n					{\r\n						_CtorS  = \"function \" + cClassNode.Name + \"(iAA)\\r\\n\";\r\n						_CtorS += \"{\\r\\n\";\r\n						{\r\n							if(cNeedsBaseInvoc) _CtorS += \"\\t\" + cBaseClassN.ID + \".call(this, iAA != undefined ? iAA : {});\\r\\n\";\r\n							if(cNeedsFieldsInit)\r\n							{\r\n								_CtorS += \"\\r\\n\\r\\n\\tif(iAA == undefined) iAA = {};\\r\\n\\t{\\r\\n\";\r\n								\r\n								for(var cFieldN,Fi = 0; cFieldN = cFieldNN[Fi]; Fi++)\r\n								{\r\n									var cName  = cFieldN.Name.substring(1);\r\n									var cValue = cFieldN.Value;\r\n\r\n									switch(cValue.name)\r\n									{\r\n										case \"_boo\" : cValue = cValue.length == 1 ? false   : cValue.call();                 break;\r\n										case \"_num\" : cValue = cValue.length == 1 ? 0       : cValue.call();                 break;\r\n										case \"_str\" : cValue = cValue.length == 1 ? \"\\\"\\\"\"  : \"\\\"\" + cValue.call() + \"\\\"\";   break;\r\n										case \"_arr\" : cValue = \"[]\";                                                         break;\r\n										case \"_nil\" : cValue = \"null\";                                                       break;\r\n\r\n										case \"_obj\" :\r\n										{\r\n											if(cValue.length == 2)\r\n											{\r\n												var _CtorInfo    = cValue.call();\r\n\r\n												if(typeof(_CtorInfo.ObjOrAlias) == \"string\")\r\n												{\r\n													//if(_CtorInfo.ObjOrAlias.indexOf(\"THREE.Scene\") != -1) debugger;\r\n\r\n													var _CtorPathM   = _CtorInfo.ObjOrAlias.match(/^(\\w+)(.*)$/);\r\n													var _RefNsP      = _CtorPathM[1]; //~~ 'Colors' in Colors.White;\r\n													//var _CtorAA      = Array.prototype.slice.call(_CtorInfo.Args, 1).map(function(cA){return cA == self ? \"this\" : cA});\r\n													var _CtorAA      = Array.prototype.slice.call(_CtorInfo.Args, 1);\r\n													{\r\n														for(var cA,Ai = 0; cA = _CtorAA[Ai], Ai < _CtorAA.length; Ai++)\r\n														{\r\n															if(typeof(cA) == \"object\") _CtorAA[Ai] = JSON.stringify(_CtorAA[Ai]);\r\n															if(cA == self)             _CtorAA[Ai] = \"this\";\r\n														}\r\n													}\r\n													\r\n													var _ClosureInfo = cFieldN.Items[0].Pack.Closures[_RefNsP];\r\n													{\r\n														if(!_ClosureInfo && window[_RefNsP])\r\n														{\r\n															//~~_ClosureInfo = {ID : _CtorInfo.ObjOrAlias};\r\n															_ClosureInfo = {ID : _RefNsP};\r\n														}\r\n													}\r\n													\r\n													if(_ClosureInfo) cValue = \"new \" + _ClosureInfo.ID + _CtorPathM[2] + \"(\" + _CtorAA.join(\",\").replace(this.Config.SelfRgx, \"$1this$2\") + \")\";\r\n													else $.AddMessage($.MessageType.FatalError, \"CLOSURES\", \"Referenced class not found: '\" + _CtorInfo.Path + \"'\", cFieldN.ID, [cFieldN.Items[0].Pack.File.Url]);\r\n												}\r\n												else\r\n												{\r\n													var _ObjS = JSON.stringify(_CtorInfo.ObjOrAlias);\r\n													{\r\n														_ObjS = _ObjS.replace(this.Config.SelfRgx, \"$1this$2\");	\r\n													}\r\n													cValue = _ObjS;\r\n												}\r\n											}\r\n											else cValue = \"{}\";\r\n\r\n											break;\r\n										}\r\n									}\r\n									\r\n									_CtorS += \"\\t\\tthis.\" + cName + \" = iAA.\" + cName + \" !== undefined ? iAA.\" + cName + \" : \" + cValue + \";\\r\\n\";\r\n								}\r\n\r\n								if(_CtorS.match(\"new undefined\")) debugger;\r\n								_CtorS += \"\\t}\\r\\n\";\r\n							}\r\n							if(cCtorExists)     _CtorS += \"\\tiUDefCtorF.apply(this, arguments);\\r\\n\";\r\n						}\r\n						_CtorS += \"}\";\r\n					}\r\n					else\r\n					{\r\n						if(cCtorIsAnonym)\r\n						{\r\n							_CtorS = cCtorNode.Value.toString().replace(/^\\s*function\\s*(\\w*)/, \"function \" + cClassNode.Name);\r\n						}\r\n						else continue;\r\n					}\r\n				}\r\n				cCtorNode = new $.Node(cCtorNodeId);\r\n				{\r\n					cCtorNode.Type = $.ObjectType.Constructor;\r\n					cCtorNode.IsAutoGen = true;\r\n\r\n					cCtorNode.Items.push(new $.NodeItem(cCtorNode.ID, Function(\"iUDefCtorF\",\"return \" + _CtorS).call(null, cCtorFunc), undefined));\r\n				}\r\n			}\r\n			$.Nodes[cCtorNodeId] = cCtorNode;\r\n			$.Routines.LinkNodes(cClassNode, cCtorNode);\r\n		}\r\n	 };\r\n	$.CompletePrototypes         = function()\r\n	 {\r\n		var fComplete = function(iClassN)\r\n		{\r\n			if(iClassN.BaseClass)\r\n			{\r\n				if(iClassN.BaseClass.Type == $.ObjectType.Class) fComplete(iClassN.BaseClass);\r\n				else\r\n				{\r\n					$.AddMessage($.MessageType.FatalError, \"CLSINHER\", \"Object '\" + iClassN.BaseClass.ID + \"' of type '\" + iClassN.BaseClass.Type + \"' is used as a base class\", iClassN.ID);\r\n					iClassN.BaseClass = undefined;\r\n				}\r\n			}\r\n\r\n			if(!iClassN.IsProtoComplete)\r\n			{\r\n				var _ProtoI = $.Routines.GetPrototypeInfo(iClassN);\r\n\r\n				if(_ProtoI.IsModified)\r\n				{\r\n					iClassN.Constructor.Value.prototype = _ProtoI.IsPrimary ? _ProtoI.Value : Object.create(iClassN.Constructor.Value.prototype, _ProtoI.Value);\r\n				}\r\n				iClassN.IsProtoComplete = true;\r\n			}\r\n		};\r\n\r\n		for(var cNodeId in Object.getProperties($.Nodes))\r\n		{\r\n			var cNode = $.Nodes[cNodeId]; if(cNode.Type == $.ObjectType.Class)\r\n			{\r\n				fComplete(cNode);\r\n			}\r\n		}\r\n	 };\r\n	$.CreateStructure            = function(iRootO)\r\n	 {\r\n		A : for(var cNodeId in Object.getProperties($.Nodes))\r\n		{\r\n			B : for\r\n			(\r\n				var \r\n				\r\n				cNsIdLL    = cNodeId.split('.'),\r\n				cNsIdLi    = 0,\r\n				cNsIdLevN  ,\r\n				cNsIdSlice ,\r\n				cNsDesc    ,\r\n				cNode      ,\r\n				pNsDesc    = {value : iRootO},\r\n				pNsId      = \"\"\r\n				;\r\n				cNsIdLevN  = cNsIdLL[cNsIdLi],\r\n				cNsIdSlice = pNsId != \"\" ? pNsId + \".\" + cNsIdLevN : cNsIdLevN,\r\n				cNode      = $.Nodes[cNsIdSlice],\r\n				cNsDesc    = Object.getOwnPropertyDescriptor(pNsDesc.value, cNsIdLevN),\r\n				cNsIdLi    < cNsIdLL.length\r\n				;\r\n				pNsDesc    = cNsDesc,\r\n				pNsId      = cNsIdSlice,\r\n				cNsIdLi    ++\r\n			)\r\n			{\r\n				if(!cNsDesc)\r\n				{\r\n					if(!cNode) throw \"WTF: Node not found: '\" + cNsIdSlice + \"'\";\r\n					\r\n					if(cNode.IsInstMember)\r\n					{\r\n						break;\r\n					}\r\n					else\r\n					{\r\n						cNsDesc = $.Routines.CreateDescriptor(cNode);\r\n\r\n						if(cNode.Type == $.ObjectType.Value || cNode.Type == $.ObjectType.Array || cNode.Type == $.ObjectType.Undefined)\r\n						{\r\n							Object.defineProperty(pNsDesc.value, cNsIdLevN, {value : cNode.Value, writable : true, enumarable : true});\r\n							break;\r\n						}\r\n						else if(cNode.Type == $.ObjectType.Oncer)\r\n						{\r\n							Object.defineProperty(pNsDesc.value, cNsIdLevN, cNsDesc);\r\n							break;\r\n						}\r\n						else\r\n						{\r\n							if((cNode.Type == $.ObjectType.Function || cNode.Type == $.ObjectType.Initializer) && cNode.Parent != undefined)\r\n							{\r\n								cNsDesc = {value : cNsDesc.value.bind(pNsDesc.value)};\r\n							}\r\n							\r\n							Object.defineProperty(pNsDesc.value, cNsIdLevN, cNsDesc);\r\n\r\n							if(cNode.Type == $.ObjectType.Property) break;\r\n						}\r\n					}\r\n				}\r\n			}\r\n		}\r\n	 };\r\n	$.CreateClassList            = function()\r\n	 {\r\n		window.$Classes = [];\r\n\r\n		for(var cNodeId in Object.getProperties($.Nodes))\r\n		{\r\n			var cN = $.Nodes[cNodeId];\r\n			{\r\n				if(!cN.Parent)                                                             continue;\r\n				if( cN.Parent.Type != $.ObjectType.Class)                                  continue;\r\n				if(!cN.Parent.BaseClass)                                                   continue;\r\n				if( cN.Type != $.ObjectType.Method && cN.Type != $.ObjectType.Constructor) continue;\r\n			}\r\n\r\n			for(var cI,Ii = 0; cI = cN.Items[Ii]; Ii++)\r\n			{\r\n				var cBaClaIdxMM = cI.Value.toString().match(/\\$Classes\\[\\d+\\]/g);\r\n				\r\n				if(cBaClaIdxMM != null)\r\n				{\r\n					for(var cM,Mi = 0; cM = cBaClaIdxMM[Mi], Mi < cBaClaIdxMM.length; Mi++)\r\n					{\r\n						for(var cParentN = cN, cM = cM.match(/^\\$Classes\\[(\\d+)\\]$/); cParentN != undefined; cParentN = $.Nodes[cN.Parent.ID])\r\n						{\r\n							if(cParentN.Type == $.ObjectType.Class)\r\n							{\r\n								if(cParentN.BaseClass)\r\n								{\r\n									$Classes[cM[1]] = cParentN.BaseClass.Constructor.Value;//Items[0].Value;\r\n								}\r\n								else this.AddMessage($.MessageType.FatalError, \"NOTFOUND\", \"Base class not found\", cN.ID, cI.Pack.File.Url);\r\n\r\n								break;\r\n							}\r\n							else continue; //~~ Any overriden class member requires class existance;\r\n						}\r\n					}\r\n				}\r\n			}\r\n		}\r\n	 };\r\n	$.InitClosures               = function()\r\n	 {\r\n		for(var cUrl in Object.getProperties($.Files))\r\n		{\r\n			$.Files[cUrl].Packs.forEach(function(cPack){cPack.Close && cPack.Close()});\r\n		}\r\n	 };\r\n	$.InitClasses                = function()\r\n	 {\r\n		for(var cNodeId in Object.getProperties($.Nodes))\r\n		{\r\n			var cNode = $.Nodes[cNodeId]; if(cNode.Type == $.ObjectType.Initializer)\r\n			{\r\n				cNode.Value.call(cNode.Parent.Constructor.Value);\r\n			}\r\n		}\r\n	 };\r\n	$.InitPacks                  = function()\r\n	 {\r\n		for(var cUrl in Object.getProperties($.Files))\r\n		{\r\n			$.Files[cUrl].Packs.forEach(function(cPack){cPack.Init && cPack.Init.call()});\r\n		}\r\n	 };\r\n	\r\n	$.list                       = function(iSrcListO)\r\n	 {\r\n		for(var cUrl in iSrcListO)\r\n		{\r\n			if(!iSrcListO.hasOwnProperty(cUrl)) continue;\r\n			if($.SourceList .hasOwnProperty(cUrl)) throw \"Source '\" + cUrl + \"' is already registered\";\r\n\r\n			$.SourceList[cUrl] = iSrcListO[cUrl];\r\n		}\r\n	 },\r\n	$.init                       = function()\r\n	 {\r\n		//console.time(\"Source\");\r\n		{\r\n			$.CreateFiles              ();        //~~ Create source files;\r\n			$.CreateNodes              (false);   //~~ Create source nodes (to take closed items from);\r\n			$.CreateClosureTables      ();        //~~ Generate closure tables from 'uses' lists and sibling items id's;\r\n			$.TransformFiles           ();        //~~ Transform file SourceList with embedded closures;\r\n\r\n			//console.timeEnd(\"Source\");\r\n		}\r\n		//console.time(\"Transformed\");\r\n		{\r\n			$.CreateNodes              (true);    //~~ Regenerate nodes with the closure initialization functions;\r\n			$.CreateClosureTables      ();        //~~ Regenerate aliases to resolve field initializers in constructors;\r\n			$.ProcessInheritance       ();        //~~ Create inheritance links between nodes;\r\n			$.CreateConstructors       ();        //~~ Generate missing class constructors;\r\n			$.CompletePrototypes       ();        //~~ Build constructor function prototypes;\r\n			\r\n			$.CreateStructure          (window);  //~~ Create hierarchy of namespaces and objects (classes, functions etc); \r\n			$.CreateClassList          ();        //~~ ;\r\n			\r\n			//console.info               ($.Nodes);\r\n			\r\n			$.InitClosures             ();        //~~ Initialize closed aliases;\r\n			$.InitClasses              ();        //~~ Invoke class initializers;\r\n			$.InitPacks                ();        //~~ Invoke pack initializers;\r\n			\r\n			//console.timeEnd(\"Transformed\");\r\n		}\r\n\r\n		$.IsInitComplete = true;\r\n\r\n		if(0 || $.IsFailedState)\r\n		{\r\n			if($.Debug)\r\n			{\r\n				document.body.style.backgroundColor = \"#ffffff\";\r\n				document.body.style.backgroundImage = \"none\";\r\n				document.body.innerHTML = $.Debug.BuildReport();\r\n			}\r\n		}\r\n		else\r\n		{\r\n			$.IsRuntimeState = true;\r\n			$.run();\r\n		}\r\n	 };\r\n	$.run                        = function()\r\n	 {\r\n		if      ($.EntryPoints.length == 1) $.EntryPoints[0].Main.call();\r\n		else if ($.EntryPoints.length > 1)  $.AddMessage($.MessageType.FatalError, \"ENTPOINT\", \"Found \" + $.EntryPoints.length + \" entry points\", [], $.EntryPoints.map(function(iPack){return iPack.File;}), []); \r\n		else if ($.OnLoad)                  $.OnLoad()\r\n		else                                $.AddMessage($.MessageType.FatalError, \"ENTPOINT\", \"Entry point not found\");\r\n	 };\r\n};\r\n\r\nObject.defineProperties\r\n (\r\n	Object,\r\n	{\r\n		specialPropertyNames : {value : /^toString|toSource|valueOf|ToString|ToSource|ValueOf$/},\r\n		getProperties : {value : function(iObj,iDoIncAll)\r\n		{\r\n			if(iDoIncAll == undefined) iDoIncAll = false;\r\n			var oOwnFF = {};\r\n			{\r\n				for(var _MemNN = Object.getOwnPropertyNames(iObj), cMemN,Ni = 0; cMemN = _MemNN[Ni], Ni < _MemNN.length; Ni++)\r\n				{\r\n					if(cMemN == \"toSource\") continue;\r\n\r\n					if(iObj.hasOwnProperty(cMemN) || (iDoIncAll && iObj[cMemN] != undefined))\r\n					{\r\n						oOwnFF[cMemN] = undefined;// this[cMemN];\r\n					}\r\n				}\r\n			}\r\n			return oOwnFF;\r\n		}},\r\n		getDescriptors : {value : function(iObj,iDoIncAll)\r\n		{\r\n			if(iDoIncAll == undefined) iDoIncAll = false;\r\n			\r\n			var oOwnFF = {};\r\n			{\r\n				if(iDoIncAll)\r\n				{\r\n					for(var _MemNN = Object.getOwnPropertyNames(iObj), cMemN, Mi = 0; cMemN = _MemNN[Mi], Mi < _MemNN.length; Mi++)\r\n					{\r\n						oOwnFF[cMemN] = Object.getOwnPropertyDescriptor(iObj, cMemN);\r\n					}\r\n				}\r\n				else\r\n				{\r\n					for(var cMemN in iObj)\r\n					{\r\n						if(iObj.hasOwnProperty(cMemN))\r\n						{\r\n							var cMemD = Object.getOwnPropertyDescriptor(iObj, cMemN);\r\n\r\n							oOwnFF[cMemN] = cMemD;\r\n						}\r\n					}\r\n				}\r\n			}\r\n			return oOwnFF;\r\n		}},\r\n	}\r\n );\r\n//# sourceURL=jstuff://JStuff/Core\r\n",
	"../JStuff/Debug.js" : "\"use strict\";\r\n\r\n$.Debug          = {};\r\n{\r\n	$.Debug.Files         = [],\r\n	$.Debug.Packs         = [],\r\n	$.Debug.Items         = [],\r\n	$.Debug.Nodes         = [],\r\n	\r\n	$.Debug.Notifications = 0,\r\n	$.Debug.Tips          = 0,\r\n	$.Debug.Warnings      = 0,\r\n	$.Debug.Errors        = 0,\r\n	$.Debug.FatalErrors   = 0,\r\n	\r\n	$.Debug.TotalMessages = 0,\r\n	\r\n	$.Debug.Logs          =\r\n	 {\r\n		\"JSERRORS\" : {Records : [], Description: \"JavaScript syntax, semantics and early referencing\"  },\r\n		\"DODOCODE\" : {Records : [], Description: \"Invalid or obsolete syntax, semantics or structure\" },\r\n		\"WTFERROR\" : {Records : [], Description: \"It's something wrong\"                                },\r\n		\"NOTFOUND\" : {Records : [], Description: \"Something not found\"                                 },\r\n		\"ITEMCONF\" : {Records : [], Description: \"Item conflicts\"                                      },\r\n		\"TYPECONF\" : {Records : [], Description: \"Type conflicts\"                                      },\r\n		\"STRUCTER\" : {Records : [], Description: \"Module structure\"                                    },\r\n		\"CLOSURES\" : {Records : [], Description: \"Closure conflicts\"                                   },\r\n		\"CLSINHER\" : {Records : [], Description: \"Class inheritance\"                                   },\r\n		\"ENTPOINT\" : {Records : [], Description: \"Application entry points\"                            },\r\n		\"CODECONV\" : {Records : [], Description: \"Code design conventions\"                             },\r\n		\"PERFTIPS\" : {Records : [], Description: \"Performance tips\"                                    },\r\n	 },\r\n\r\n	$.Debug.AddLogRecord  = function(iType, iLogN, iText, iDefII, iFileUU, iLineNN)\r\n	 {\r\n		this.Logs[iLogN].Records.push({Type : iType, Message : iText, Definitions : iDefII, Files : iFileUU, Lines : iLineNN});\r\n		\r\n		switch(iType)\r\n		{\r\n			case $.MessageType.Notification : this.Notifications ++; break;\r\n			case $.MessageType.Tip          : this.Tips          ++; break;\r\n			case $.MessageType.Warning      : this.Warnings      ++; break;\r\n			case $.MessageType.Error        : this.Errors        ++; break;\r\n			case $.MessageType.FatalError   : this.FatalErrors   ++; break;\r\n			\r\n			default : throw \"WTF\";\r\n		}\r\n	 },\r\n	$.Debug.BuildReport   = function()\r\n	 {\r\n		var _FormatID       = function(iIdS,  iDoIncP) {return \"<nobr>\" + iIdS.replace(/(.*\\.)?([_A-Za-z0-9]+\\.)?([_A-Za-z0-9]+)$/g, (iDoIncP ? \"$1\" : \"\") + \"<span title=\\\"$&\\\" class=\\\"MajStr\\\"><b>$2$3</b></span>\") + \"</nobr>\";};\r\n		var _FormatUrl      = function(iUrlS, iDoIncP) {return iUrlS != \"\" ? iUrlS .replace(/(.*\\/)([\\.\\w]+)(:\\d+)?$/g, (iDoIncP ? \"$1\" : \"\") + \"<span title=\\\"$&\\\" class=\\\"MajStr\\\">$2$3</span>\") : \"<span class=\\\"MinStr\\\">--</span>\";};\r\n		var _FormatMessage  = function(iMsg)           {return iMsg.replace(new RegExp(\"'([^']*)'\",\"g\"), \"<b>$1</b>\");};\r\n		var _FormatNodeType = function(iTypeS)          \r\n		 {\r\n			iTypeS = iTypeS.toLowerCase();\r\n			\r\n			var _Color;\r\n			{\r\n				switch(iTypeS)\r\n				{\r\n					case \"value\"       : _Color = \"#00aaff\"; break;\r\n					case \"class\"       : _Color = \"#66aa00\"; break;\r\n					case \"instance\"    : _Color = \"#aa0000\"; break;\r\n					case \"static\"      : _Color = \"#aa0000\"; break;\r\n					case \"field\"       : _Color = \"#00ff00\"; break;\r\n					case \"function\"    : _Color = \"#00aaff\"; break;\r\n					case \"method\"      : _Color = \"#00aaff\"; break;\r\n					case \"property\"    : _Color = \"#ff6600\"; break;\r\n					case \"initializer\" : _Color = \"#aa0000\"; break;\r\n					case \"constructor\" : _Color = \"#aa0000\"; break;\r\n					\r\n					\r\n					default            : _Color = \"#cccccc\";\r\n				}\r\n			}\r\n			return \"<span style=\\\"color: \" + _Color + \"\\\">\" + iTypeS + \"</span>\";\r\n		 };\r\n		var _FormatItemType = function(iIsInstM)        \r\n		 {\r\n			return \"<span style=\\\"font-weight: bold; color: \" + (iIsInstM ? \"#000000\" : \"#cccccc\") + \"\\\">\" + (iIsInstM ? \"+\" : \"-\") + \"</span>\";\r\n		 };\r\n		var _FormatValue    = function(iI)              \r\n		 {\r\n			var iV = iI.Value;\r\n			var iT = typeof(iI.Value);\r\n			var oHTML = \"\";\r\n			{\r\n				if(iT == \"object\")\r\n				{\r\n					if(iV == null) oHTML = \"null\";\r\n					else oHTML = \"[Object]\";\r\n				}\r\n				else if(iT == \"undefined\") oHTML = \"undefined\";\r\n				else oHTML = \"???\";\r\n			}\r\n			return oHTML;\r\n		 };\r\n		var _FormatSources  = function(iDefII)          \r\n		 {\r\n			var oSrcS = \"\";\r\n			{\r\n				var _UniqueSS = [];\r\n				{\r\n					for(var cS,Si = 0; cS = iDefII[Si], Si < iDefII.length; Si++)\r\n					{\r\n						if(!_UniqueSS.some(function(iS){return iS.Url == cS.Url;}))\r\n						{\r\n							_UniqueSS.push(cS);\r\n						}\r\n					}\r\n					_UniqueSS.forEach\r\n					(\r\n						function(iS,iI)\r\n						{\r\n							_UniqueSS[iI] = _FormatID(iS,false);\r\n						}\r\n					);\r\n				}\r\n				oSrcS = _UniqueSS.join(\"<br/>\");\r\n			}\r\n			return oSrcS;\r\n		 };\r\n		var _FormatFiles    = function(iFileUU, iLineNN)\r\n		 {\r\n			var oFilesS = \"\";\r\n			{\r\n				var _UniqueII = [];\r\n				{\r\n					for(var cId,Fi = 0; cId = iFileUU[Fi] + (iLineNN[Fi] != undefined? \":\" + iLineNN[Fi] : \"\"), Fi < iFileUU.length; Fi++) if(!_UniqueII.some(function(iId){return iId == cId;}))_UniqueII.push(cId);\r\n					\r\n					_UniqueII.forEach(function(iId,iI){_UniqueII[iI] = _FormatUrl(iId);});\r\n				}\r\n				oFilesS =  _UniqueII.length > 0 ? _UniqueII.join(\"<br/>\") : \"<nobr>--</nobr>\";\r\n			}\r\n			return oFilesS;\r\n		 };\r\n\r\n		var oHTML = \"\";\r\n		{\r\n			oHTML +=\r\n			\"<html>\\\r\n				<head>\\\r\n					\\\r\n					<style>\\\r\n						BODY					{font-family: tahoma; font-size: 12px; margin: 0; padding: 0; background-color: #ffffff}\\\r\n						\\\r\n						H1						{margin: 20px 25px 20px 25px; font-family: verdana; font-weight: normal}\\\r\n						#Content				{padding: 0px 40px 30px 40px}\\\r\n						\\\r\n						#Content > DIV		{}\\\r\n						TABLE					{}\\\r\n							TR.LogDesc TD	{font-size: 14px; font-weight: bold; padding: 5px 10px}\\\r\n							TR.EmptyRow		{height: 20px}\\\r\n						\\\r\n							TR.Even			{background-color: #fafafa}\\\r\n							TR.Even:hover,\\\r\n							   .Odd:hover	{background-color: #fff0e0; outline: #ffaa00 1px solid}\\\r\n								TD				{font-size: 12px; padding: 3px 10px; vertical-align: top;}\\\r\n							\\\r\n							.MinStr			{color: #cc0000; font-weight: normal}\\\r\n							.MajStr			{color: #cc0000}\\\r\n							.File				{color: #cc0000}\\\r\n						\\\r\n						.ApxSrc				{color: #888888}\\\r\n						\\\r\n					</style>\\\r\n				</head>\\\r\n				<body>\\\r\n					<div id=\\\"Header\\\"></div></div>\\\r\n					<h1><span style=\\\"color: #cc0000\\\">O</span>ops...</h1>\\\r\n					<div id=\\\"Content\\\">\";\r\n					{\r\n						oHTML += \"<table cellspacing=\\\"0\\\">\"; for(var cLogN in Object.getProperties(this.Logs))\r\n						{\r\n							if(!cLogN.match(/^[A-Z]+$/)) continue;\r\n							\r\n							var cLog = this.Logs[cLogN];\r\n							{\r\n								if(cLog.Records.length == 0) continue;\r\n								 \r\n								oHTML += \"<tr class=\\\"LogDesc\\\"><td colspan=\\\"3\\\">\" + (cLog.Description || cLogN) + \"</td></tr>\";\r\n								{\r\n									for(var cR,Ri = 0; cR = cLog.Records[Ri], Ri < cLog.Records.length; Ri++)\r\n									{\r\n										oHTML += \"<tr class=\\\"LogItem \" + (Ri % 2 ? \"Even\" : \"Odd\") + \"\\\"><td style=\\\"padding-left: 30px\\\">\" + _FormatSources(cR.Definitions) + \"</td><td width=\\\"100%\\\">\" + _FormatMessage(cR.Message) + \"</td><td>\" + (cR.Files != undefined ? _FormatFiles(cR.Files, cR.Lines) : \"-\") + \"</td></tr>\";\r\n									}\r\n								}\r\n								oHTML += \"<tr class=\\\"EmptyRow\\\"><td colspan=\\\"3\\\"></td></tr>\";\r\n							}\r\n						}\r\n						oHTML += \"</table>\";\r\n					}\r\n					//~~ Item table;\r\n					if(0)\r\n					{\r\n						oHTML += \"<table cellspacing=\\\"0\\\"><tr><td>ItemN</td><td>NodeT</td><td>IsInstM</td><td>Value</td><td>File</td></tr>\";\r\n\r\n						for(var cI,Ii = 0; cI = this.Items[Ii]; Ii++)\r\n						{\r\n							oHTML += \"<tr class=\\\"\" + (Ii % 2 ? \"Even\" : \"Odd\") + \"\\\"><td>\" + _FormatID(cI.ID, true) + \"</td><td><b>\" + _FormatNodeType(cI.Node.Type) + \"</b></td><td>\" + _FormatItemType(cI.IsInstMember) + \"</td><td width=\\\"100%\\\" style=\\\"font-family: courier\\\">\" + _FormatValue(cI) + \"</td><td>\" + _FormatUrl(cI.Pack ? cI.Pack.File.Url : \"\", false) + \"</td></tr>\";\r\n						}\r\n						oHTML += \"</table>\";\r\n					}\r\n					//~~ Node table;\r\n					if(0)\r\n					{\r\n						oHTML += \"<table cellspacing=\\\"0\\\"><tr><td>DefId</td><td>DefType</td><td>AutoGen</td><td>IsInstM</td><td>ItemCnt</td></tr>\";\r\n\r\n						for(var cN,Ni = 0; cN = this.Nodes[Ni]; Ni++)\r\n						{\r\n							oHTML += \"<tr class=\\\"\" + (Ni % 2 ? \"Even\" : \"Odd\")  + \"\\\">\\\r\n											<td>\"       + _FormatID(cN.ID, true)                 + \"</td>\\\r\n											<td><b>\"    + _FormatNodeType(cN.Type)               + \"</b></td>\\\r\n											<td>\"       + (cN.IsAutoGen ? \"+\" : \"-\")             + \"</td>\\\r\n											<td>\"       + _FormatItemType(cN.IsInstMember)       + \"</td>\\\r\n											<td>\"       + cN.Items.length                        + \"</td>\\\r\n										</tr>\";\r\n						}\r\n						oHTML += \"</table>\";\r\n					}\r\n					\r\n					oHTML += \"</div>\\\r\n					<div id=\\\"Footer\\\"></div>\\\r\n				</body>\\\r\n			</html>\";\r\n		}\r\n		return oHTML;\r\n	 }\r\n	$.Debug.ParseNodes    = function(iNN)\r\n	 {\r\n		for(var cNodeId in iNN)\r\n		{\r\n			this.Nodes.push({ID : cNodeId, Value : iNN[cNodeId]});\r\n		}\r\n		this.Nodes.sort\r\n		(\r\n			function(ixN,iyN)\r\n			{\r\n				ixN = ixN.ID;\r\n				iyN = iyN.ID;\r\n\r\n				for(var Ci = 0; Ci < Math.min(ixN.length, iyN.length); Ci++)\r\n				{\r\n					var cxC = ixN.charAt(Ci);\r\n					var cyC = iyN.charAt(Ci);\r\n					\r\n					if(cxC == cyC) continue;\r\n					else return cxC > cyC ? +1 : -1;\r\n				}\r\n			}\r\n		);\r\n\r\n	 };\r\n};",
});